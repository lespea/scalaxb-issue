// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package scalaxb.error.types

trait AccessComplexityEnumType

object AccessComplexityEnumType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): AccessComplexityEnumType = value match {
    case "HIGH"   ⇒ HIGHValue2
    case "MEDIUM" ⇒ MEDIUMValue2
    case "LOW"    ⇒ LOWValue2

  }
}

case object HIGHValue2 extends AccessComplexityEnumType { override def toString = "HIGH" }
case object MEDIUMValue2 extends AccessComplexityEnumType { override def toString = "MEDIUM" }
case object LOWValue2 extends AccessComplexityEnumType { override def toString = "LOW" }

trait AccessVectorEnumType

object AccessVectorEnumType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): AccessVectorEnumType = value match {
    case "LOCAL"            ⇒ LOCAL
    case "ADJACENT_NETWORK" ⇒ ADJACENT_NETWORK
    case "NETWORK"          ⇒ NETWORK

  }
}

case object LOCAL extends AccessVectorEnumType { override def toString = "LOCAL" }
case object ADJACENT_NETWORK extends AccessVectorEnumType { override def toString = "ADJACENT_NETWORK" }
case object NETWORK extends AccessVectorEnumType { override def toString = "NETWORK" }

trait CiaRequirementEnumType

object CiaRequirementEnumType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): CiaRequirementEnumType = value match {
    case "LOW"         ⇒ LOWValue
    case "MEDIUM"      ⇒ MEDIUMValue
    case "HIGH"        ⇒ HIGHValue
    case "NOT_DEFINED" ⇒ NOT_DEFINEDValue2

  }
}

case object LOWValue extends CiaRequirementEnumType { override def toString = "LOW" }
case object MEDIUMValue extends CiaRequirementEnumType { override def toString = "MEDIUM" }
case object HIGHValue extends CiaRequirementEnumType { override def toString = "HIGH" }
case object NOT_DEFINEDValue2 extends CiaRequirementEnumType { override def toString = "NOT_DEFINED" }

trait CollateralDamagePotentialEnumType

object CollateralDamagePotentialEnumType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): CollateralDamagePotentialEnumType = value match {
    case "NONE"        ⇒ NONEValue2
    case "LOW"         ⇒ LOWValue3
    case "LOW_MEDIUM"  ⇒ LOW_MEDIUM
    case "MEDIUM_HIGH" ⇒ MEDIUM_HIGH
    case "HIGH"        ⇒ HIGHValue3
    case "NOT_DEFINED" ⇒ NOT_DEFINEDValue3

  }
}

case object NONEValue2 extends CollateralDamagePotentialEnumType { override def toString = "NONE" }
case object LOWValue3 extends CollateralDamagePotentialEnumType { override def toString = "LOW" }
case object LOW_MEDIUM extends CollateralDamagePotentialEnumType { override def toString = "LOW_MEDIUM" }
case object MEDIUM_HIGH extends CollateralDamagePotentialEnumType { override def toString = "MEDIUM_HIGH" }
case object HIGHValue3 extends CollateralDamagePotentialEnumType { override def toString = "HIGH" }
case object NOT_DEFINEDValue3 extends CollateralDamagePotentialEnumType { override def toString = "NOT_DEFINED" }

trait TargetDistributionEnumType

object TargetDistributionEnumType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TargetDistributionEnumType = value match {
    case "NONE"        ⇒ NONEValue
    case "LOW"         ⇒ LOW
    case "MEDIUM"      ⇒ MEDIUM
    case "HIGH"        ⇒ HIGH
    case "NOT_DEFINED" ⇒ NOT_DEFINEDValue

  }
}

case object NONEValue extends TargetDistributionEnumType { override def toString = "NONE" }
case object LOW extends TargetDistributionEnumType { override def toString = "LOW" }
case object MEDIUM extends TargetDistributionEnumType { override def toString = "MEDIUM" }
case object HIGH extends TargetDistributionEnumType { override def toString = "HIGH" }
case object NOT_DEFINEDValue extends TargetDistributionEnumType { override def toString = "NOT_DEFINED" }

trait CiaEnumType

object CiaEnumType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): CiaEnumType = value match {
    case "NONE"     ⇒ NONEValue3
    case "PARTIAL"  ⇒ PARTIAL
    case "COMPLETE" ⇒ COMPLETE

  }
}

case object NONEValue3 extends CiaEnumType { override def toString = "NONE" }
case object PARTIAL extends CiaEnumType { override def toString = "PARTIAL" }
case object COMPLETE extends CiaEnumType { override def toString = "COMPLETE" }

trait AuthenticationEnumType

object AuthenticationEnumType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): AuthenticationEnumType = value match {
    case "MULTIPLE_INSTANCES" ⇒ MULTIPLE_INSTANCES
    case "SINGLE_INSTANCE"    ⇒ SINGLE_INSTANCE
    case "NONE"               ⇒ NONE

  }
}

case object MULTIPLE_INSTANCES extends AuthenticationEnumType { override def toString = "MULTIPLE_INSTANCES" }
case object SINGLE_INSTANCE extends AuthenticationEnumType { override def toString = "SINGLE_INSTANCE" }
case object NONE extends AuthenticationEnumType { override def toString = "NONE" }

trait RemediationLevelEnumType

object RemediationLevelEnumType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): RemediationLevelEnumType = value match {
    case "OFFICIAL_FIX"  ⇒ OFFICIAL_FIX
    case "TEMPORARY_FIX" ⇒ TEMPORARY_FIX
    case "WORKAROUND"    ⇒ WORKAROUND
    case "UNAVAILABLE"   ⇒ UNAVAILABLE
    case "NOT_DEFINED"   ⇒ NOT_DEFINEDValue4

  }
}

case object OFFICIAL_FIX extends RemediationLevelEnumType { override def toString = "OFFICIAL_FIX" }
case object TEMPORARY_FIX extends RemediationLevelEnumType { override def toString = "TEMPORARY_FIX" }
case object WORKAROUND extends RemediationLevelEnumType { override def toString = "WORKAROUND" }
case object UNAVAILABLE extends RemediationLevelEnumType { override def toString = "UNAVAILABLE" }
case object NOT_DEFINEDValue4 extends RemediationLevelEnumType { override def toString = "NOT_DEFINED" }

trait ConfidenceEnumType

object ConfidenceEnumType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ConfidenceEnumType = value match {
    case "UNCONFIRMED"    ⇒ UNCONFIRMED
    case "UNCORROBORATED" ⇒ UNCORROBORATED
    case "CONFIRMED"      ⇒ CONFIRMED
    case "NOT_DEFINED"    ⇒ NOT_DEFINED

  }
}

case object UNCONFIRMED extends ConfidenceEnumType { override def toString = "UNCONFIRMED" }
case object UNCORROBORATED extends ConfidenceEnumType { override def toString = "UNCORROBORATED" }
case object CONFIRMED extends ConfidenceEnumType { override def toString = "CONFIRMED" }
case object NOT_DEFINED extends ConfidenceEnumType { override def toString = "NOT_DEFINED" }

trait ExploitabilityEnumType

object ExploitabilityEnumType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ExploitabilityEnumType = value match {
    case "UNPROVEN"         ⇒ UNPROVEN
    case "PROOF_OF_CONCEPT" ⇒ PROOF_OF_CONCEPT
    case "FUNCTIONAL"       ⇒ FUNCTIONAL
    case "HIGH"             ⇒ HIGHValue4
    case "NOT_DEFINED"      ⇒ NOT_DEFINEDValue5

  }
}

case object UNPROVEN extends ExploitabilityEnumType { override def toString = "UNPROVEN" }
case object PROOF_OF_CONCEPT extends ExploitabilityEnumType { override def toString = "PROOF_OF_CONCEPT" }
case object FUNCTIONAL extends ExploitabilityEnumType { override def toString = "FUNCTIONAL" }
case object HIGHValue4 extends ExploitabilityEnumType { override def toString = "HIGH" }
case object NOT_DEFINEDValue5 extends ExploitabilityEnumType { override def toString = "NOT_DEFINED" }

case class AccessComplexityType(value: scalaxb.error.types.AccessComplexityEnumType,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val approximated = attributes("@approximated").as[Boolean]
}

case class AccessVectorType(value: scalaxb.error.types.AccessVectorEnumType,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val approximated = attributes("@approximated").as[Boolean]
}

case class CiaRequirementType(value: scalaxb.error.types.CiaRequirementEnumType,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val approximated = attributes("@approximated").as[Boolean]
}

case class CollateralDamagePotentialType(value: scalaxb.error.types.CollateralDamagePotentialEnumType,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val approximated = attributes("@approximated").as[Boolean]
}

case class TargetDistributionType(value: scalaxb.error.types.TargetDistributionEnumType,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val approximated = attributes("@approximated").as[Boolean]
}

case class CiaType(value: scalaxb.error.types.CiaEnumType,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val approximated = attributes("@approximated").as[Boolean]
}

case class AuthenticationType(value: scalaxb.error.types.AuthenticationEnumType,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val approximated = attributes("@approximated").as[Boolean]
}

case class RemediationLevelType(value: scalaxb.error.types.RemediationLevelEnumType,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val approximated = attributes("@approximated").as[Boolean]
}

case class ConfidenceType(value: scalaxb.error.types.ConfidenceEnumType,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val approximated = attributes("@approximated").as[Boolean]
}

case class ExploitabilityType(value: scalaxb.error.types.ExploitabilityEnumType,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val approximated = attributes("@approximated").as[Boolean]
}

/**
 * "This schema was intentionally designed to avoid mixing classes and attributes between CVSS version 1, CVSS version 2, and future versions. Scores in the CVSS system are interdependent.  The temporal score is a multiplier of the base score.  The environmental score, in turn, is a multiplier of the temporal score.  The ability to transfer these scores independently is provided on the assumption that the user understands the business logic. For any given metric, it is preferred that the score, as a minimum is provided, however the score can be re-created from the metrics or the multiplier and any scores they are dependent on."
 */
trait CvssTypable {
  val base_metrics: Seq[scalaxb.error.types.BaseMetricsType]
  val environmental_metrics: Seq[scalaxb.error.types.EnvironmentalMetricsType]
  val temporal_metrics: Seq[scalaxb.error.types.TemporalMetricsType]
}

/**
 * "This schema was intentionally designed to avoid mixing classes and attributes between CVSS version 1, CVSS version 2, and future versions. Scores in the CVSS system are interdependent.  The temporal score is a multiplier of the base score.  The environmental score, in turn, is a multiplier of the temporal score.  The ability to transfer these scores independently is provided on the assumption that the user understands the business logic. For any given metric, it is preferred that the score, as a minimum is provided, however the score can be re-created from the metrics or the multiplier and any scores they are dependent on."
 */
case class CvssType(base_metrics: Seq[scalaxb.error.types.BaseMetricsType] = Nil,
  environmental_metrics: Seq[scalaxb.error.types.EnvironmentalMetricsType] = Nil,
  temporal_metrics: Seq[scalaxb.error.types.TemporalMetricsType] = Nil) extends CvssTypable

case class CvssImpactType(base_metrics: Seq[scalaxb.error.types.BaseMetricsType] = Nil,
  environmental_metrics: Seq[scalaxb.error.types.EnvironmentalMetricsType] = Nil,
  temporal_metrics: Seq[scalaxb.error.types.TemporalMetricsType] = Nil) extends CvssTypable

trait CvssImpactBaseTypable {
  val base_metrics: scalaxb.error.types.BaseMetricsType
}

case class CvssImpactBaseType(base_metrics: scalaxb.error.types.BaseMetricsType) extends CvssImpactBaseTypable

trait CvssImpactTemporalTypable extends CvssImpactBaseTypable {
  val base_metrics: scalaxb.error.types.BaseMetricsType
  val temporal_metrics: Option[scalaxb.error.types.TemporalMetricsType]
}

case class CvssImpactTemporalType(base_metrics: scalaxb.error.types.BaseMetricsType,
  temporal_metrics: Option[scalaxb.error.types.TemporalMetricsType] = None) extends CvssImpactTemporalTypable

case class CvssImpactEnvironmentalType(base_metrics: scalaxb.error.types.BaseMetricsType,
  temporal_metrics: Option[scalaxb.error.types.TemporalMetricsType] = None,
  environmental_metrics: Option[scalaxb.error.types.EnvironmentalMetricsType] = None) extends CvssImpactTemporalTypable

/**
 * Base type for metrics that defines common attributes of all metrics.
 */
trait MetricsType {
  val upgradedu45fromu45version: Option[BigDecimal]
}

case class BaseMetricsType(score: Option[BigDecimal] = None,
    exploitu45subscore: Option[BigDecimal] = None,
    impactu45subscore: Option[BigDecimal] = None,
    baseVectorsGroupSequence5: scalaxb.error.types.BaseVectorsGroupSequence,
    source: java.net.URI,
    generatedu45onu45datetime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends MetricsType {
  lazy val upgradedu45fromu45version = attributes.get("@upgraded-from-version") map { _.as[BigDecimal] }
}

case class EnvironmentalMetricsType(score: Option[BigDecimal] = None,
    environmentalVectorsGroupSequence3: scalaxb.error.types.EnvironmentalVectorsGroupSequence,
    source: java.net.URI,
    generatedu45onu45datetime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends MetricsType {
  lazy val upgradedu45fromu45version = attributes.get("@upgraded-from-version") map { _.as[BigDecimal] }
}

case class TemporalMetricsType(score: Option[BigDecimal] = None,
    temporalu45multiplier: Option[BigDecimal] = None,
    temporalVectorsGroupSequence4: scalaxb.error.types.TemporalVectorsGroupSequence,
    source: java.net.URI,
    generatedu45onu45datetime: javax.xml.datatype.XMLGregorianCalendar,
    attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends MetricsType {
  lazy val upgradedu45fromu45version = attributes.get("@upgraded-from-version") map { _.as[BigDecimal] }
}

case class TemporalVectorsCriteriaGroupSequence(exploitability: Option[scalaxb.error.types.ExploitabilityEnumType] = None,
  remediationu45level: Option[scalaxb.error.types.RemediationLevelEnumType] = None,
  reportu45confidence: Option[scalaxb.error.types.ConfidenceEnumType] = None)

case class BaseVectorsCriteriaGroupSequence(accessu45vector: Option[scalaxb.error.types.AccessVectorEnumType] = None,
  accessu45complexity: Option[scalaxb.error.types.AccessComplexityEnumType] = None,
  authentication: Option[scalaxb.error.types.AuthenticationEnumType] = None,
  confidentialityu45impact: Option[scalaxb.error.types.CiaEnumType] = None,
  integrityu45impact: Option[scalaxb.error.types.CiaEnumType] = None,
  availabilityu45impact: Option[scalaxb.error.types.CiaEnumType] = None)

case class EnvironmentalVectorsGroupSequence(collateralu45damageu45potential: Option[scalaxb.error.types.CollateralDamagePotentialType] = None,
  targetu45distribution: Option[scalaxb.error.types.TargetDistributionType] = None,
  confidentialityu45requirement: Option[scalaxb.error.types.CiaRequirementType] = None,
  integrityu45requirement: Option[scalaxb.error.types.CiaRequirementType] = None,
  availabilityu45requirement: Option[scalaxb.error.types.CiaRequirementType] = None)

case class BaseVectorsGroupSequence(accessu45vector: Option[scalaxb.error.types.AccessVectorType] = None,
  accessu45complexity: Option[scalaxb.error.types.AccessComplexityType] = None,
  authentication: Option[scalaxb.error.types.AuthenticationType] = None,
  confidentialityu45impact: Option[scalaxb.error.types.CiaType] = None,
  integrityu45impact: Option[scalaxb.error.types.CiaType] = None,
  availabilityu45impact: Option[scalaxb.error.types.CiaType] = None)

case class TemporalVectorsGroupSequence(exploitability: Option[scalaxb.error.types.ExploitabilityType] = None,
  remediationu45level: Option[scalaxb.error.types.RemediationLevelType] = None,
  reportu45confidence: Option[scalaxb.error.types.ConfidenceType] = None)

case class EnvironmentalVectorsCriteriaGroupSequence(collateralu45damageu45potential: Option[scalaxb.error.types.CollateralDamagePotentialEnumType] = None,
  targetu45distribution: Option[scalaxb.error.types.TargetDistributionEnumType] = None,
  confidentialityu45requirement: Option[scalaxb.error.types.CiaRequirementEnumType] = None,
  integrityu45requirement: Option[scalaxb.error.types.CiaRequirementEnumType] = None,
  availabilityu45requirement: Option[scalaxb.error.types.CiaRequirementEnumType] = None)

case class VectorAttributeGroup(approximated: Boolean)


// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package scalaxb.error

import scala.concurrent.Future

/**
 * usage:
 * val obj = scalaxb.fromXML[scalaxb.error.Foo](node)
 * val document = scalaxb.toXML[scalaxb.error.Foo](obj, "foo", scalaxb.error.defaultScope)
 */
object `package` extends XMLProtocol {}

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  implicit lazy val executionContext = scala.concurrent.ExecutionContext.Implicits.global

  val defaultScope = scalaxb.toScope(Some("cpe") -> "http://cpe.mitre.org/language/2.0",
    Some("cvrf") -> "http://www.icasi.org/CVRF/schema/cvrf/1.1",
    Some("cvrf-common") -> "http://www.icasi.org/CVRF/schema/common/1.1",
    Some("cvssv2") -> "http://scap.nist.gov/schema/cvss-v2/1.0",
    Some("dc") -> "http://purl.org/dc/elements/1.1/",
    Some("prod") -> "http://www.icasi.org/CVRF/schema/prod/1.1",
    Some("scap-core") -> "http://scap.nist.gov/schema/scap-core/1.0",
    Some("vuln") -> "http://www.icasi.org/CVRF/schema/vuln/1.1",
    Some("xml") -> "http://www.w3.org/XML/1998/namespace",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val TypesLocalizedStringableFormat: scalaxb.XMLFormat[scalaxb.error.types.LocalizedStringable] = new DefaultTypesLocalizedStringableFormat {}
  implicit lazy val TypesLocalizedStringFormat: scalaxb.XMLFormat[scalaxb.error.types.LocalizedString] = new DefaultTypesLocalizedStringFormat {}
  implicit lazy val TypesLocalizedNormalizedStringableFormat: scalaxb.XMLFormat[scalaxb.error.types.LocalizedNormalizedStringable] = new DefaultTypesLocalizedNormalizedStringableFormat {}
  implicit lazy val TypesLocalizedNormalizedStringFormat: scalaxb.XMLFormat[scalaxb.error.types.LocalizedNormalizedString] = new DefaultTypesLocalizedNormalizedStringFormat {}
  implicit lazy val TypesReferenceTypeEnumFormat: scalaxb.XMLFormat[scalaxb.error.types.ReferenceTypeEnum] = new DefaultTypesReferenceTypeEnumFormat {}
  implicit lazy val TypesPublisherEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.PublisherEnumType] = new DefaultTypesPublisherEnumTypeFormat {}
  implicit lazy val TypesNoteTypeEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.NoteTypeEnumType] = new DefaultTypesNoteTypeEnumTypeFormat {}
  implicit lazy val TypesPlatformSpecificationTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.PlatformSpecificationType] = new DefaultTypesPlatformSpecificationTypeFormat {}
  implicit lazy val TypesPlatformBaseTypableFormat: scalaxb.XMLFormat[scalaxb.error.types.PlatformBaseTypable] = new DefaultTypesPlatformBaseTypableFormat {}
  implicit lazy val TypesPlatformBaseTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.PlatformBaseType] = new DefaultTypesPlatformBaseTypeFormat {}
  implicit lazy val TypesPlatformTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.PlatformType] = new DefaultTypesPlatformTypeFormat {}
  implicit lazy val TypesLogicalTestTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.LogicalTestType] = new DefaultTypesLogicalTestTypeFormat {}
  implicit lazy val TypesFactRefTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.FactRefType] = new DefaultTypesFactRefTypeFormat {}
  implicit lazy val TypesOperatorEnumerationFormat: scalaxb.XMLFormat[scalaxb.error.types.OperatorEnumeration] = new DefaultTypesOperatorEnumerationFormat {}
  implicit lazy val TypesTextTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.TextType] = new DefaultTypesTextTypeFormat {}
  implicit lazy val TypesDocumentStatusEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.DocumentStatusEnumType] = new DefaultTypesDocumentStatusEnumTypeFormat {}
  implicit lazy val TypesDocumentTitleFormat: scalaxb.XMLFormat[scalaxb.error.types.DocumentTitle] = new DefaultTypesDocumentTitleFormat {}
  implicit lazy val TypesDocumentTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.DocumentType] = new DefaultTypesDocumentTypeFormat {}
  implicit lazy val TypesContactDetailsFormat: scalaxb.XMLFormat[scalaxb.error.types.ContactDetails] = new DefaultTypesContactDetailsFormat {}
  implicit lazy val TypesIssuingAuthorityFormat: scalaxb.XMLFormat[scalaxb.error.types.IssuingAuthority] = new DefaultTypesIssuingAuthorityFormat {}
  implicit lazy val TypesDocumentPublisherFormat: scalaxb.XMLFormat[scalaxb.error.types.DocumentPublisher] = new DefaultTypesDocumentPublisherFormat {}
  implicit lazy val TypesIDFormat: scalaxb.XMLFormat[scalaxb.error.types.ID] = new DefaultTypesIDFormat {}
  implicit lazy val TypesAliasFormat: scalaxb.XMLFormat[scalaxb.error.types.Alias] = new DefaultTypesAliasFormat {}
  implicit lazy val TypesIdentificationFormat: scalaxb.XMLFormat[scalaxb.error.types.Identification] = new DefaultTypesIdentificationFormat {}
  implicit lazy val TypesDescriptionFormat: scalaxb.XMLFormat[scalaxb.error.types.Description] = new DefaultTypesDescriptionFormat {}
  implicit lazy val TypesRevisionFormat: scalaxb.XMLFormat[scalaxb.error.types.Revision] = new DefaultTypesRevisionFormat {}
  implicit lazy val TypesRevisionHistoryFormat: scalaxb.XMLFormat[scalaxb.error.types.RevisionHistory] = new DefaultTypesRevisionHistoryFormat {}
  implicit lazy val TypesEngineFormat: scalaxb.XMLFormat[scalaxb.error.types.Engine] = new DefaultTypesEngineFormat {}
  implicit lazy val TypesGeneratorFormat: scalaxb.XMLFormat[scalaxb.error.types.Generator] = new DefaultTypesGeneratorFormat {}
  implicit lazy val TypesDocumentTrackingFormat: scalaxb.XMLFormat[scalaxb.error.types.DocumentTracking] = new DefaultTypesDocumentTrackingFormat {}
  implicit lazy val TypesNoteFormat: scalaxb.XMLFormat[scalaxb.error.types.Note] = new DefaultTypesNoteFormat {}
  implicit lazy val TypesDocumentNotesFormat: scalaxb.XMLFormat[scalaxb.error.types.DocumentNotes] = new DefaultTypesDocumentNotesFormat {}
  implicit lazy val TypesDocumentDistributionFormat: scalaxb.XMLFormat[scalaxb.error.types.DocumentDistribution] = new DefaultTypesDocumentDistributionFormat {}
  implicit lazy val TypesAggregateSeverityFormat: scalaxb.XMLFormat[scalaxb.error.types.AggregateSeverity] = new DefaultTypesAggregateSeverityFormat {}
  implicit lazy val TypesDescription2Format: scalaxb.XMLFormat[scalaxb.error.types.Description2] = new DefaultTypesDescription2Format {}
  implicit lazy val TypesReferenceFormat: scalaxb.XMLFormat[scalaxb.error.types.Reference] = new DefaultTypesReferenceFormat {}
  implicit lazy val TypesDocumentReferencesFormat: scalaxb.XMLFormat[scalaxb.error.types.DocumentReferences] = new DefaultTypesDocumentReferencesFormat {}
  implicit lazy val TypesNameFormat: scalaxb.XMLFormat[scalaxb.error.types.Name] = new DefaultTypesNameFormat {}
  implicit lazy val TypesOrganizationFormat: scalaxb.XMLFormat[scalaxb.error.types.Organization] = new DefaultTypesOrganizationFormat {}
  implicit lazy val TypesDescription3Format: scalaxb.XMLFormat[scalaxb.error.types.Description3] = new DefaultTypesDescription3Format {}
  implicit lazy val TypesAcknowledgmentFormat: scalaxb.XMLFormat[scalaxb.error.types.Acknowledgment] = new DefaultTypesAcknowledgmentFormat {}
  implicit lazy val TypesAcknowledgmentsFormat: scalaxb.XMLFormat[scalaxb.error.types.Acknowledgments] = new DefaultTypesAcknowledgmentsFormat {}
  implicit lazy val TypesCvrfdocFormat: scalaxb.XMLFormat[scalaxb.error.types.Cvrfdoc] = new DefaultTypesCvrfdocFormat {}
  implicit lazy val TypesAccessComplexityEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.AccessComplexityEnumType] = new DefaultTypesAccessComplexityEnumTypeFormat {}
  implicit lazy val TypesAccessVectorEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.AccessVectorEnumType] = new DefaultTypesAccessVectorEnumTypeFormat {}
  implicit lazy val TypesCiaRequirementEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CiaRequirementEnumType] = new DefaultTypesCiaRequirementEnumTypeFormat {}
  implicit lazy val TypesCollateralDamagePotentialEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CollateralDamagePotentialEnumType] = new DefaultTypesCollateralDamagePotentialEnumTypeFormat {}
  implicit lazy val TypesTargetDistributionEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.TargetDistributionEnumType] = new DefaultTypesTargetDistributionEnumTypeFormat {}
  implicit lazy val TypesCiaEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CiaEnumType] = new DefaultTypesCiaEnumTypeFormat {}
  implicit lazy val TypesAuthenticationEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.AuthenticationEnumType] = new DefaultTypesAuthenticationEnumTypeFormat {}
  implicit lazy val TypesRemediationLevelEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.RemediationLevelEnumType] = new DefaultTypesRemediationLevelEnumTypeFormat {}
  implicit lazy val TypesConfidenceEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.ConfidenceEnumType] = new DefaultTypesConfidenceEnumTypeFormat {}
  implicit lazy val TypesExploitabilityEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.ExploitabilityEnumType] = new DefaultTypesExploitabilityEnumTypeFormat {}
  implicit lazy val TypesAccessComplexityTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.AccessComplexityType] = new DefaultTypesAccessComplexityTypeFormat {}
  implicit lazy val TypesAccessVectorTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.AccessVectorType] = new DefaultTypesAccessVectorTypeFormat {}
  implicit lazy val TypesCiaRequirementTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CiaRequirementType] = new DefaultTypesCiaRequirementTypeFormat {}
  implicit lazy val TypesCollateralDamagePotentialTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CollateralDamagePotentialType] = new DefaultTypesCollateralDamagePotentialTypeFormat {}
  implicit lazy val TypesTargetDistributionTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.TargetDistributionType] = new DefaultTypesTargetDistributionTypeFormat {}
  implicit lazy val TypesCiaTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CiaType] = new DefaultTypesCiaTypeFormat {}
  implicit lazy val TypesAuthenticationTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.AuthenticationType] = new DefaultTypesAuthenticationTypeFormat {}
  implicit lazy val TypesRemediationLevelTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.RemediationLevelType] = new DefaultTypesRemediationLevelTypeFormat {}
  implicit lazy val TypesConfidenceTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.ConfidenceType] = new DefaultTypesConfidenceTypeFormat {}
  implicit lazy val TypesExploitabilityTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.ExploitabilityType] = new DefaultTypesExploitabilityTypeFormat {}
  implicit lazy val TypesCvssTypableFormat: scalaxb.XMLFormat[scalaxb.error.types.CvssTypable] = new DefaultTypesCvssTypableFormat {}
  implicit lazy val TypesCvssTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CvssType] = new DefaultTypesCvssTypeFormat {}
  implicit lazy val TypesCvssImpactTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CvssImpactType] = new DefaultTypesCvssImpactTypeFormat {}
  implicit lazy val TypesCvssImpactBaseTypableFormat: scalaxb.XMLFormat[scalaxb.error.types.CvssImpactBaseTypable] = new DefaultTypesCvssImpactBaseTypableFormat {}
  implicit lazy val TypesCvssImpactBaseTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CvssImpactBaseType] = new DefaultTypesCvssImpactBaseTypeFormat {}
  implicit lazy val TypesCvssImpactTemporalTypableFormat: scalaxb.XMLFormat[scalaxb.error.types.CvssImpactTemporalTypable] = new DefaultTypesCvssImpactTemporalTypableFormat {}
  implicit lazy val TypesCvssImpactTemporalTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CvssImpactTemporalType] = new DefaultTypesCvssImpactTemporalTypeFormat {}
  implicit lazy val TypesCvssImpactEnvironmentalTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CvssImpactEnvironmentalType] = new DefaultTypesCvssImpactEnvironmentalTypeFormat {}
  implicit lazy val TypesMetricsTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.MetricsType] = new DefaultTypesMetricsTypeFormat {}
  implicit lazy val TypesBaseMetricsTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.BaseMetricsType] = new DefaultTypesBaseMetricsTypeFormat {}
  implicit lazy val TypesEnvironmentalMetricsTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.EnvironmentalMetricsType] = new DefaultTypesEnvironmentalMetricsTypeFormat {}
  implicit lazy val TypesTemporalMetricsTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.TemporalMetricsType] = new DefaultTypesTemporalMetricsTypeFormat {}
  implicit lazy val TypesTemporalVectorsCriteriaGroupSequenceFormat: scalaxb.XMLFormat[scalaxb.error.types.TemporalVectorsCriteriaGroupSequence] = new DefaultTypesTemporalVectorsCriteriaGroupSequenceFormat {}
  implicit lazy val TypesBaseVectorsCriteriaGroupSequenceFormat: scalaxb.XMLFormat[scalaxb.error.types.BaseVectorsCriteriaGroupSequence] = new DefaultTypesBaseVectorsCriteriaGroupSequenceFormat {}
  implicit lazy val TypesEnvironmentalVectorsGroupSequenceFormat: scalaxb.XMLFormat[scalaxb.error.types.EnvironmentalVectorsGroupSequence] = new DefaultTypesEnvironmentalVectorsGroupSequenceFormat {}
  implicit lazy val TypesBaseVectorsGroupSequenceFormat: scalaxb.XMLFormat[scalaxb.error.types.BaseVectorsGroupSequence] = new DefaultTypesBaseVectorsGroupSequenceFormat {}
  implicit lazy val TypesTemporalVectorsGroupSequenceFormat: scalaxb.XMLFormat[scalaxb.error.types.TemporalVectorsGroupSequence] = new DefaultTypesTemporalVectorsGroupSequenceFormat {}
  implicit lazy val TypesEnvironmentalVectorsCriteriaGroupSequenceFormat: scalaxb.XMLFormat[scalaxb.error.types.EnvironmentalVectorsCriteriaGroupSequence] = new DefaultTypesEnvironmentalVectorsCriteriaGroupSequenceFormat {}
  implicit lazy val TypesVectorAttributeGroupFormat: scalaxb.AttributeGroupFormat[scalaxb.error.types.VectorAttributeGroup] = new DefaultTypesVectorAttributeGroupFormat {}
  implicit lazy val TypesSimpleLiteralFormat: scalaxb.XMLFormat[scalaxb.error.types.SimpleLiteral] = new DefaultTypesSimpleLiteralFormat {}
  implicit lazy val TypesElementContainerFormat: scalaxb.XMLFormat[scalaxb.error.types.ElementContainer] = new DefaultTypesElementContainerFormat {}
  implicit lazy val TypesBranchTypeEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.BranchTypeEnumType] = new DefaultTypesBranchTypeEnumTypeFormat {}
  implicit lazy val TypesRelationTypeEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.RelationTypeEnumType] = new DefaultTypesRelationTypeEnumTypeFormat {}
  implicit lazy val TypesBranchTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.BranchType] = new DefaultTypesBranchTypeFormat {}
  implicit lazy val TypesRelationshipFormat: scalaxb.XMLFormat[scalaxb.error.types.Relationship] = new DefaultTypesRelationshipFormat {}
  implicit lazy val TypesDescription4Format: scalaxb.XMLFormat[scalaxb.error.types.Description4] = new DefaultTypesDescription4Format {}
  implicit lazy val TypesGroupFormat: scalaxb.XMLFormat[scalaxb.error.types.Group] = new DefaultTypesGroupFormat {}
  implicit lazy val TypesProductGroupsFormat: scalaxb.XMLFormat[scalaxb.error.types.ProductGroups] = new DefaultTypesProductGroupsFormat {}
  implicit lazy val TypesProductTreeFormat: scalaxb.XMLFormat[scalaxb.error.types.ProductTree] = new DefaultTypesProductTreeFormat {}
  implicit lazy val TypesFullProductNameFormat: scalaxb.XMLFormat[scalaxb.error.types.FullProductName] = new DefaultTypesFullProductNameFormat {}
  implicit lazy val TypesCheckReferenceTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CheckReferenceType] = new DefaultTypesCheckReferenceTypeFormat {}
  implicit lazy val TypesCheckSearchTypableFormat: scalaxb.XMLFormat[scalaxb.error.types.CheckSearchTypable] = new DefaultTypesCheckSearchTypableFormat {}
  implicit lazy val TypesCheckSearchTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.CheckSearchType] = new DefaultTypesCheckSearchTypeFormat {}
  implicit lazy val TypesSearchableCpeReferencesTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.SearchableCpeReferencesType] = new DefaultTypesSearchableCpeReferencesTypeFormat {}
  implicit lazy val TypesControlMappingsTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.ControlMappingsType] = new DefaultTypesControlMappingsTypeFormat {}
  implicit lazy val TypesControlMappingTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.ControlMappingType] = new DefaultTypesControlMappingTypeFormat {}
  implicit lazy val TypesMappingInstanceTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.MappingInstanceType] = new DefaultTypesMappingInstanceTypeFormat {}
  implicit lazy val TypesAssessmentMethodTypableFormat: scalaxb.XMLFormat[scalaxb.error.types.AssessmentMethodTypable] = new DefaultTypesAssessmentMethodTypableFormat {}
  implicit lazy val TypesAssessmentMethodTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.AssessmentMethodType] = new DefaultTypesAssessmentMethodTypeFormat {}
  implicit lazy val TypesIdentifyableAssessmentMethodTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.IdentifyableAssessmentMethodType] = new DefaultTypesIdentifyableAssessmentMethodTypeFormat {}
  implicit lazy val TypesInvolvementStatusEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.InvolvementStatusEnumType] = new DefaultTypesInvolvementStatusEnumTypeFormat {}
  implicit lazy val TypesAffectedStatusEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.AffectedStatusEnumType] = new DefaultTypesAffectedStatusEnumTypeFormat {}
  implicit lazy val TypesThreatTypeEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.ThreatTypeEnumType] = new DefaultTypesThreatTypeEnumTypeFormat {}
  implicit lazy val TypesRemedyTypeEnumTypeFormat: scalaxb.XMLFormat[scalaxb.error.types.RemedyTypeEnumType] = new DefaultTypesRemedyTypeEnumTypeFormat {}
  implicit lazy val TypesTitleFormat: scalaxb.XMLFormat[scalaxb.error.types.Title] = new DefaultTypesTitleFormat {}
  implicit lazy val TypesID2Format: scalaxb.XMLFormat[scalaxb.error.types.ID2] = new DefaultTypesID2Format {}
  implicit lazy val TypesNote2Format: scalaxb.XMLFormat[scalaxb.error.types.Note2] = new DefaultTypesNote2Format {}
  implicit lazy val TypesNotesFormat: scalaxb.XMLFormat[scalaxb.error.types.Notes] = new DefaultTypesNotesFormat {}
  implicit lazy val TypesDescription5Format: scalaxb.XMLFormat[scalaxb.error.types.Description5] = new DefaultTypesDescription5Format {}
  implicit lazy val TypesInvolvementFormat: scalaxb.XMLFormat[scalaxb.error.types.Involvement] = new DefaultTypesInvolvementFormat {}
  implicit lazy val TypesInvolvementsFormat: scalaxb.XMLFormat[scalaxb.error.types.Involvements] = new DefaultTypesInvolvementsFormat {}
  implicit lazy val TypesCWEFormat: scalaxb.XMLFormat[scalaxb.error.types.CWE] = new DefaultTypesCWEFormat {}
  implicit lazy val TypesStatusFormat: scalaxb.XMLFormat[scalaxb.error.types.Status] = new DefaultTypesStatusFormat {}
  implicit lazy val TypesProductStatusesFormat: scalaxb.XMLFormat[scalaxb.error.types.ProductStatuses] = new DefaultTypesProductStatusesFormat {}
  implicit lazy val TypesDescription6Format: scalaxb.XMLFormat[scalaxb.error.types.Description6] = new DefaultTypesDescription6Format {}
  implicit lazy val TypesThreatFormat: scalaxb.XMLFormat[scalaxb.error.types.Threat] = new DefaultTypesThreatFormat {}
  implicit lazy val TypesThreatsFormat: scalaxb.XMLFormat[scalaxb.error.types.Threats] = new DefaultTypesThreatsFormat {}
  implicit lazy val TypesScoreSetFormat: scalaxb.XMLFormat[scalaxb.error.types.ScoreSet] = new DefaultTypesScoreSetFormat {}
  implicit lazy val TypesCVSSScoreSetsFormat: scalaxb.XMLFormat[scalaxb.error.types.CVSSScoreSets] = new DefaultTypesCVSSScoreSetsFormat {}
  implicit lazy val TypesDescription7Format: scalaxb.XMLFormat[scalaxb.error.types.Description7] = new DefaultTypesDescription7Format {}
  implicit lazy val TypesEntitlementFormat: scalaxb.XMLFormat[scalaxb.error.types.Entitlement] = new DefaultTypesEntitlementFormat {}
  implicit lazy val TypesRemediationFormat: scalaxb.XMLFormat[scalaxb.error.types.Remediation] = new DefaultTypesRemediationFormat {}
  implicit lazy val TypesRemediationsFormat: scalaxb.XMLFormat[scalaxb.error.types.Remediations] = new DefaultTypesRemediationsFormat {}
  implicit lazy val TypesDescription8Format: scalaxb.XMLFormat[scalaxb.error.types.Description8] = new DefaultTypesDescription8Format {}
  implicit lazy val TypesReference2Format: scalaxb.XMLFormat[scalaxb.error.types.Reference2] = new DefaultTypesReference2Format {}
  implicit lazy val TypesReferencesFormat: scalaxb.XMLFormat[scalaxb.error.types.References] = new DefaultTypesReferencesFormat {}
  implicit lazy val TypesName2Format: scalaxb.XMLFormat[scalaxb.error.types.Name2] = new DefaultTypesName2Format {}
  implicit lazy val TypesOrganization2Format: scalaxb.XMLFormat[scalaxb.error.types.Organization2] = new DefaultTypesOrganization2Format {}
  implicit lazy val TypesDescription9Format: scalaxb.XMLFormat[scalaxb.error.types.Description9] = new DefaultTypesDescription9Format {}
  implicit lazy val TypesAcknowledgment2Format: scalaxb.XMLFormat[scalaxb.error.types.Acknowledgment2] = new DefaultTypesAcknowledgment2Format {}
  implicit lazy val TypesAcknowledgments2Format: scalaxb.XMLFormat[scalaxb.error.types.Acknowledgments2] = new DefaultTypesAcknowledgments2Format {}
  implicit lazy val TypesVulnerabilityFormat: scalaxb.XMLFormat[scalaxb.error.types.Vulnerability] = new DefaultTypesVulnerabilityFormat {}
  implicit lazy val TypesSpaceFormat: scalaxb.XMLFormat[scalaxb.error.types.Space] = new DefaultTypesSpaceFormat {}
  implicit lazy val TypesSpecialAttrsFormat: scalaxb.AttributeGroupFormat[scalaxb.error.types.SpecialAttrs] = new DefaultTypesSpecialAttrsFormat {}

  trait DefaultTypesLocalizedStringableFormat extends scalaxb.XMLFormat[scalaxb.error.types.LocalizedStringable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.LocalizedStringable] = seq match {
      case node: scala.xml.Node ⇒
        scalaxb.Helper.instanceType(node) match {

          case _ ⇒ Right(scalaxb.fromXML[scalaxb.error.types.LocalizedString](node, stack))
        }
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def writes(__obj: scalaxb.error.types.LocalizedStringable, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: scalaxb.error.types.Description9         ⇒ scalaxb.toXML[scalaxb.error.types.Description9](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Organization2        ⇒ scalaxb.toXML[scalaxb.error.types.Organization2](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Name2                ⇒ scalaxb.toXML[scalaxb.error.types.Name2](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Description8         ⇒ scalaxb.toXML[scalaxb.error.types.Description8](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Entitlement          ⇒ scalaxb.toXML[scalaxb.error.types.Entitlement](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Description7         ⇒ scalaxb.toXML[scalaxb.error.types.Description7](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Description6         ⇒ scalaxb.toXML[scalaxb.error.types.Description6](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.CWE                  ⇒ scalaxb.toXML[scalaxb.error.types.CWE](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Description5         ⇒ scalaxb.toXML[scalaxb.error.types.Description5](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Note2                ⇒ scalaxb.toXML[scalaxb.error.types.Note2](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Title                ⇒ scalaxb.toXML[scalaxb.error.types.Title](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Description4         ⇒ scalaxb.toXML[scalaxb.error.types.Description4](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Description3         ⇒ scalaxb.toXML[scalaxb.error.types.Description3](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Organization         ⇒ scalaxb.toXML[scalaxb.error.types.Organization](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Name                 ⇒ scalaxb.toXML[scalaxb.error.types.Name](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Description2         ⇒ scalaxb.toXML[scalaxb.error.types.Description2](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.AggregateSeverity    ⇒ scalaxb.toXML[scalaxb.error.types.AggregateSeverity](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.DocumentDistribution ⇒ scalaxb.toXML[scalaxb.error.types.DocumentDistribution](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Note                 ⇒ scalaxb.toXML[scalaxb.error.types.Note](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Engine               ⇒ scalaxb.toXML[scalaxb.error.types.Engine](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Description          ⇒ scalaxb.toXML[scalaxb.error.types.Description](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.Alias                ⇒ scalaxb.toXML[scalaxb.error.types.Alias](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.ID                   ⇒ scalaxb.toXML[scalaxb.error.types.ID](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.IssuingAuthority     ⇒ scalaxb.toXML[scalaxb.error.types.IssuingAuthority](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.ContactDetails       ⇒ scalaxb.toXML[scalaxb.error.types.ContactDetails](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.LocalizedString      ⇒ scalaxb.toXML[scalaxb.error.types.LocalizedString](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultTypesLocalizedStringFormat extends scalaxb.XMLFormat[scalaxb.error.types.LocalizedString] with scalaxb.CanWriteChildNodes[scalaxb.error.types.LocalizedString] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/common/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.LocalizedString] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.LocalizedString(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.LocalizedString, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.LocalizedString, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesLocalizedNormalizedStringableFormat extends scalaxb.XMLFormat[scalaxb.error.types.LocalizedNormalizedStringable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.LocalizedNormalizedStringable] = seq match {
      case node: scala.xml.Node ⇒
        scalaxb.Helper.instanceType(node) match {

          case _ ⇒ Right(scalaxb.fromXML[scalaxb.error.types.LocalizedNormalizedString](node, stack))
        }
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def writes(__obj: scalaxb.error.types.LocalizedNormalizedStringable, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: scalaxb.error.types.DocumentType              ⇒ scalaxb.toXML[scalaxb.error.types.DocumentType](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.DocumentTitle             ⇒ scalaxb.toXML[scalaxb.error.types.DocumentTitle](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.LocalizedNormalizedString ⇒ scalaxb.toXML[scalaxb.error.types.LocalizedNormalizedString](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultTypesLocalizedNormalizedStringFormat extends scalaxb.XMLFormat[scalaxb.error.types.LocalizedNormalizedString] with scalaxb.CanWriteChildNodes[scalaxb.error.types.LocalizedNormalizedString] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/common/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.LocalizedNormalizedString] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.LocalizedNormalizedString(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.LocalizedNormalizedString, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.LocalizedNormalizedString, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  def buildTypesReferenceTypeEnumFormat = new DefaultTypesReferenceTypeEnumFormat {}
  trait DefaultTypesReferenceTypeEnumFormat extends scalaxb.XMLFormat[scalaxb.error.types.ReferenceTypeEnum] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/common/1.1")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.ReferenceTypeEnum] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.ReferenceTypeEnum.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.ReferenceTypeEnum.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.ReferenceTypeEnum, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesPublisherEnumTypeFormat = new DefaultTypesPublisherEnumTypeFormat {}
  trait DefaultTypesPublisherEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.PublisherEnumType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/common/1.1")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.PublisherEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.PublisherEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.PublisherEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.PublisherEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesNoteTypeEnumTypeFormat = new DefaultTypesNoteTypeEnumTypeFormat {}
  trait DefaultTypesNoteTypeEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.NoteTypeEnumType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/common/1.1")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.NoteTypeEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.NoteTypeEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.NoteTypeEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.NoteTypeEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultTypesPlatformSpecificationTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.PlatformSpecificationType] {
    val targetNamespace: Option[String] = Some("http://cpe.mitre.org/language/2.0")

    override def typeName: Option[String] = Some("platformSpecificationType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.PlatformSpecificationType] =
      phrase(safeRep(scalaxb.ElemName(Some("http://cpe.mitre.org/language/2.0"), "platform")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.PlatformSpecificationType(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.PlatformType](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.PlatformSpecificationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.platform flatMap { scalaxb.toXML[scalaxb.error.types.PlatformType](_, Some("http://cpe.mitre.org/language/2.0"), Some("platform"), __scope, false) })

  }

  trait DefaultTypesPlatformBaseTypableFormat extends scalaxb.XMLFormat[scalaxb.error.types.PlatformBaseTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.PlatformBaseTypable] = seq match {
      case node: scala.xml.Node ⇒
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://cpe.mitre.org/language/2.0"), Some("PlatformType")) ⇒ Right(scalaxb.fromXML[scalaxb.error.types.PlatformType](node, stack))
          case _ ⇒ Right(scalaxb.fromXML[scalaxb.error.types.PlatformBaseType](node, stack))
        }
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def writes(__obj: scalaxb.error.types.PlatformBaseTypable, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: scalaxb.error.types.PlatformType     ⇒ scalaxb.toXML[scalaxb.error.types.PlatformType](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.PlatformBaseType ⇒ scalaxb.toXML[scalaxb.error.types.PlatformBaseType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultTypesPlatformBaseTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.PlatformBaseType] {
    val targetNamespace: Option[String] = Some("http://cpe.mitre.org/language/2.0")

    override def typeName: Option[String] = Some("PlatformBaseType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.PlatformBaseType] =
      phrase(safeRep(scalaxb.ElemName(Some("http://cpe.mitre.org/language/2.0"), "title")) ~
        safeRep(scalaxb.ElemName(Some("http://cpe.mitre.org/language/2.0"), "remark")) ~
        (scalaxb.ElemName(Some("http://cpe.mitre.org/language/2.0"), "logical-test")) ^^
        {
          case p1 ~ p2 ~ p3 ⇒
            scalaxb.error.types.PlatformBaseType(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.TextType](_, scalaxb.ElemName(node) :: stack) },
              p2.toSeq map { scalaxb.fromXML[scalaxb.error.types.TextType](_, scalaxb.ElemName(node) :: stack) },
              scalaxb.fromXML[scalaxb.error.types.LogicalTestType](p3, scalaxb.ElemName(node) :: stack))
        })

    def writesChildNodes(__obj: scalaxb.error.types.PlatformBaseType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.title flatMap { scalaxb.toXML[scalaxb.error.types.TextType](_, Some("http://cpe.mitre.org/language/2.0"), Some("title"), __scope, false) },
        __obj.remark flatMap { scalaxb.toXML[scalaxb.error.types.TextType](_, Some("http://cpe.mitre.org/language/2.0"), Some("remark"), __scope, false) },
        scalaxb.toXML[scalaxb.error.types.LogicalTestType](__obj.logicalu45test, Some("http://cpe.mitre.org/language/2.0"), Some("logical-test"), __scope, false))

  }

  trait DefaultTypesPlatformTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.PlatformType] {
    val targetNamespace: Option[String] = Some("http://cpe.mitre.org/language/2.0")

    override def typeName: Option[String] = Some("PlatformType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.PlatformType] =
      phrase(safeRep(scalaxb.ElemName(Some("http://cpe.mitre.org/language/2.0"), "title")) ~
        safeRep(scalaxb.ElemName(Some("http://cpe.mitre.org/language/2.0"), "remark")) ~
        (scalaxb.ElemName(Some("http://cpe.mitre.org/language/2.0"), "logical-test")) ^^
        {
          case p1 ~ p2 ~ p3 ⇒
            scalaxb.error.types.PlatformType(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.TextType](_, scalaxb.ElemName(node) :: stack) },
              p2.toSeq map { scalaxb.fromXML[scalaxb.error.types.TextType](_, scalaxb.ElemName(node) :: stack) },
              scalaxb.fromXML[scalaxb.error.types.LogicalTestType](p3, scalaxb.ElemName(node) :: stack),
              scala.collection.immutable.ListMap(List(
                (node \ "@id").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.PlatformType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) ⇒ attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case (key, x)   ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.PlatformType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.title flatMap { scalaxb.toXML[scalaxb.error.types.TextType](_, Some("http://cpe.mitre.org/language/2.0"), Some("title"), __scope, false) },
        __obj.remark flatMap { scalaxb.toXML[scalaxb.error.types.TextType](_, Some("http://cpe.mitre.org/language/2.0"), Some("remark"), __scope, false) },
        scalaxb.toXML[scalaxb.error.types.LogicalTestType](__obj.logicalu45test, Some("http://cpe.mitre.org/language/2.0"), Some("logical-test"), __scope, false))

  }

  trait DefaultTypesLogicalTestTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.LogicalTestType] {
    val targetNamespace: Option[String] = Some("http://cpe.mitre.org/language/2.0")

    override def typeName: Option[String] = Some("LogicalTestType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.LogicalTestType] =
      phrase(safeRep(scalaxb.ElemName(Some("http://cpe.mitre.org/language/2.0"), "logical-test")) ~
        safeRep(scalaxb.ElemName(Some("http://cpe.mitre.org/language/2.0"), "fact-ref")) ^^
        {
          case p1 ~ p2 ⇒
            scalaxb.error.types.LogicalTestType(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.LogicalTestType](_, scalaxb.ElemName(node) :: stack) },
              p2.toSeq map { scalaxb.fromXML[scalaxb.error.types.FactRefType](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@operator").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.OperatorEnumeration](x, scalaxb.ElemName(node) :: stack)) } map { "@operator" -> _ },
                (node \ "@negate").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@negate" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.LogicalTestType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@operator", _) ⇒ attr = scala.xml.Attribute(null, "operator", __obj.operator.toString, attr)
        case ("@negate", _)   ⇒ attr = scala.xml.Attribute(null, "negate", __obj.negate.toString, attr)
        case (key, x)         ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.LogicalTestType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.logicalu45test flatMap { scalaxb.toXML[scalaxb.error.types.LogicalTestType](_, Some("http://cpe.mitre.org/language/2.0"), Some("logical-test"), __scope, false) },
        __obj.factu45ref flatMap { scalaxb.toXML[scalaxb.error.types.FactRefType](_, Some("http://cpe.mitre.org/language/2.0"), Some("fact-ref"), __scope, false) })

  }

  trait DefaultTypesFactRefTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.FactRefType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.FactRefType] {
    val targetNamespace: Option[String] = Some("http://cpe.mitre.org/language/2.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.FactRefType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.FactRefType(scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.FactRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) ⇒ attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x)     ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.FactRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  def buildTypesOperatorEnumerationFormat = new DefaultTypesOperatorEnumerationFormat {}
  trait DefaultTypesOperatorEnumerationFormat extends scalaxb.XMLFormat[scalaxb.error.types.OperatorEnumeration] {
    val targetNamespace: Option[String] = Some("http://cpe.mitre.org/language/2.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.OperatorEnumeration] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.OperatorEnumeration.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.OperatorEnumeration.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.OperatorEnumeration, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultTypesTextTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.TextType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.TextType] {
    val targetNamespace: Option[String] = Some("http://cpe.mitre.org/language/2.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.TextType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.TextType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.TextType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ __obj.xmllang foreach { x ⇒ attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.TextType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  def buildTypesDocumentStatusEnumTypeFormat = new DefaultTypesDocumentStatusEnumTypeFormat {}
  trait DefaultTypesDocumentStatusEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.DocumentStatusEnumType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.DocumentStatusEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.DocumentStatusEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.DocumentStatusEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.DocumentStatusEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultTypesDocumentTitleFormat extends scalaxb.XMLFormat[scalaxb.error.types.DocumentTitle] with scalaxb.CanWriteChildNodes[scalaxb.error.types.DocumentTitle] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.DocumentTitle] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.DocumentTitle(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.DocumentTitle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.DocumentTitle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesDocumentTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.DocumentType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.DocumentType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.DocumentType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.DocumentType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.DocumentType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.DocumentType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesContactDetailsFormat extends scalaxb.XMLFormat[scalaxb.error.types.ContactDetails] with scalaxb.CanWriteChildNodes[scalaxb.error.types.ContactDetails] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.ContactDetails] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.ContactDetails(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.ContactDetails, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.ContactDetails, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesIssuingAuthorityFormat extends scalaxb.XMLFormat[scalaxb.error.types.IssuingAuthority] with scalaxb.CanWriteChildNodes[scalaxb.error.types.IssuingAuthority] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.IssuingAuthority] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.IssuingAuthority(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.IssuingAuthority, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.IssuingAuthority, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesDocumentPublisherFormat extends scalaxb.ElemNameParser[scalaxb.error.types.DocumentPublisher] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.DocumentPublisher] =
      phrase(opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "ContactDetails")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "IssuingAuthority")) ^^
        {
          case p1 ~ p2 ⇒
            scalaxb.error.types.DocumentPublisher(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.ContactDetails](_, scalaxb.ElemName(node) :: stack) },
              p2.headOption map { scalaxb.fromXML[scalaxb.error.types.IssuingAuthority](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@Type").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.PublisherEnumType](x, scalaxb.ElemName(node) :: stack)) } map { "@Type" -> _ },
                (node \ "@VendorID").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@VendorID" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.DocumentPublisher, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@Type", _)     ⇒ attr = scala.xml.Attribute(null, "Type", __obj.Type.toString, attr)
        case ("@VendorID", _) ⇒ __obj.VendorID foreach { x ⇒ attr = scala.xml.Attribute(null, "VendorID", x.toString, attr) }
        case (key, x)         ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.DocumentPublisher, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.ContactDetails map { scalaxb.toXML[scalaxb.error.types.ContactDetails](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("ContactDetails"), __scope, false) } getOrElse { Nil },
        __obj.IssuingAuthority map { scalaxb.toXML[scalaxb.error.types.IssuingAuthority](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("IssuingAuthority"), __scope, false) } getOrElse { Nil })

  }

  trait DefaultTypesIDFormat extends scalaxb.XMLFormat[scalaxb.error.types.ID] with scalaxb.CanWriteChildNodes[scalaxb.error.types.ID] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.ID] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.ID(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.ID, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.ID, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesAliasFormat extends scalaxb.XMLFormat[scalaxb.error.types.Alias] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Alias] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Alias] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Alias(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Alias, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Alias, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesIdentificationFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Identification] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Identification] =
      phrase((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "ID")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Alias")) ^^
        {
          case p1 ~ p2 ⇒
            scalaxb.error.types.Identification(scalaxb.fromXML[scalaxb.error.types.ID](p1, scalaxb.ElemName(node) :: stack),
              p2.toSeq map { scalaxb.fromXML[scalaxb.error.types.Alias](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.Identification, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[scalaxb.error.types.ID](__obj.ID, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("ID"), __scope, false),
        __obj.Alias flatMap { scalaxb.toXML[scalaxb.error.types.Alias](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Alias"), __scope, false) })

  }

  trait DefaultTypesDescriptionFormat extends scalaxb.XMLFormat[scalaxb.error.types.Description] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Description] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Description] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Description(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Description, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Description, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesRevisionFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Revision] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Revision] =
      phrase((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Number")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Date")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Description")) ^^
        {
          case p1 ~ p2 ~ p3 ⇒
            scalaxb.error.types.Revision(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](p2, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[scalaxb.error.types.Description](p3, scalaxb.ElemName(node) :: stack))
        })

    def writesChildNodes(__obj: scalaxb.error.types.Revision, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.Number, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Number"), __scope, false),
        scalaxb.toXML[javax.xml.datatype.XMLGregorianCalendar](__obj.Date, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Date"), __scope, false),
        scalaxb.toXML[scalaxb.error.types.Description](__obj.Description, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Description"), __scope, false))

  }

  trait DefaultTypesRevisionHistoryFormat extends scalaxb.ElemNameParser[scalaxb.error.types.RevisionHistory] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.RevisionHistory] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Revision")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.RevisionHistory(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Revision](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.RevisionHistory, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Revision flatMap { scalaxb.toXML[scalaxb.error.types.Revision](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Revision"), __scope, false) })

  }

  trait DefaultTypesEngineFormat extends scalaxb.XMLFormat[scalaxb.error.types.Engine] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Engine] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Engine] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Engine(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Engine, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Engine, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesGeneratorFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Generator] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Generator] =
      phrase(opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Engine")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Date")) ^^
        {
          case p1 ~ p2 ⇒
            scalaxb.error.types.Generator(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.Engine](_, scalaxb.ElemName(node) :: stack) },
              p2.headOption map { scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.Generator, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.Engine map { scalaxb.toXML[scalaxb.error.types.Engine](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Engine"), __scope, false) } getOrElse { Nil },
        __obj.Date map { scalaxb.toXML[javax.xml.datatype.XMLGregorianCalendar](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Date"), __scope, false) } getOrElse { Nil })

  }

  trait DefaultTypesDocumentTrackingFormat extends scalaxb.ElemNameParser[scalaxb.error.types.DocumentTracking] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.DocumentTracking] =
      phrase((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Identification")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Status")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Version")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "RevisionHistory")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "InitialReleaseDate")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "CurrentReleaseDate")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Generator")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ⇒
            scalaxb.error.types.DocumentTracking(scalaxb.fromXML[scalaxb.error.types.Identification](p1, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[scalaxb.error.types.DocumentStatusEnumType](p2, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[String](p3, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[scalaxb.error.types.RevisionHistory](p4, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](p5, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](p6, scalaxb.ElemName(node) :: stack),
              p7.headOption map { scalaxb.fromXML[scalaxb.error.types.Generator](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.DocumentTracking, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[scalaxb.error.types.Identification](__obj.Identification, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Identification"), __scope, false),
        scalaxb.toXML[scalaxb.error.types.DocumentStatusEnumType](__obj.Status, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Status"), __scope, false),
        scalaxb.toXML[String](__obj.Version, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Version"), __scope, false),
        scalaxb.toXML[scalaxb.error.types.RevisionHistory](__obj.RevisionHistory, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("RevisionHistory"), __scope, false),
        scalaxb.toXML[javax.xml.datatype.XMLGregorianCalendar](__obj.InitialReleaseDate, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("InitialReleaseDate"), __scope, false),
        scalaxb.toXML[javax.xml.datatype.XMLGregorianCalendar](__obj.CurrentReleaseDate, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("CurrentReleaseDate"), __scope, false),
        __obj.Generator map { scalaxb.toXML[scalaxb.error.types.Generator](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Generator"), __scope, false) } getOrElse { Nil })

  }

  trait DefaultTypesNoteFormat extends scalaxb.XMLFormat[scalaxb.error.types.Note] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Note] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Note] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Note(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
          (node \ "@Title").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@Title" -> _ },
          (node \ "@Audience").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@Audience" -> _ },
          (node \ "@Type").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.NoteTypeEnumType](x, scalaxb.ElemName(node) :: stack)) } map { "@Type" -> _ },
          (node \ "@Ordinal").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@Ordinal" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Note, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case ("@Title", _) ⇒ __obj.Title foreach { x ⇒ attr = scala.xml.Attribute(null, "Title", x.toString, attr) }
        case ("@Audience", _) ⇒ __obj.Audience foreach { x ⇒ attr = scala.xml.Attribute(null, "Audience", x.toString, attr) }
        case ("@Type", _) ⇒ attr = scala.xml.Attribute(null, "Type", __obj.Type.toString, attr)
        case ("@Ordinal", _) ⇒ attr = scala.xml.Attribute(null, "Ordinal", __obj.Ordinal.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Note, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesDocumentNotesFormat extends scalaxb.ElemNameParser[scalaxb.error.types.DocumentNotes] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.DocumentNotes] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Note")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.DocumentNotes(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Note](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.DocumentNotes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Note flatMap { scalaxb.toXML[scalaxb.error.types.Note](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Note"), __scope, false) })

  }

  trait DefaultTypesDocumentDistributionFormat extends scalaxb.XMLFormat[scalaxb.error.types.DocumentDistribution] with scalaxb.CanWriteChildNodes[scalaxb.error.types.DocumentDistribution] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.DocumentDistribution] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.DocumentDistribution(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.DocumentDistribution, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.DocumentDistribution, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesAggregateSeverityFormat extends scalaxb.XMLFormat[scalaxb.error.types.AggregateSeverity] with scalaxb.CanWriteChildNodes[scalaxb.error.types.AggregateSeverity] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.AggregateSeverity] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.AggregateSeverity(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
          (node \ "@Namespace").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@Namespace" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.AggregateSeverity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case ("@Namespace", _) ⇒ __obj.Namespace foreach { x ⇒ attr = scala.xml.Attribute(null, "Namespace", x.toString, attr) }
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.AggregateSeverity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesDescription2Format extends scalaxb.XMLFormat[scalaxb.error.types.Description2] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Description2] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Description2] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Description2(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Description2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Description2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesReferenceFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Reference] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Reference] =
      phrase((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "URL")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Description")) ^^
        {
          case p1 ~ p2 ⇒
            scalaxb.error.types.Reference(scalaxb.fromXML[java.net.URI](p1, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[scalaxb.error.types.Description2](p2, scalaxb.ElemName(node) :: stack),
              scala.collection.immutable.ListMap(List(
                (node \ "@Type").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.ReferenceTypeEnum](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[scalaxb.error.types.ReferenceTypeEnum](scala.xml.Text("External"), scalaxb.ElemName(node) :: stack))) map { "@Type" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.Reference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@Type", _) ⇒ if (__obj.Type.toString != "External") attr = scala.xml.Attribute(null, "Type", __obj.Type.toString, attr)
        case (key, x)     ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Reference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[java.net.URI](__obj.URL, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("URL"), __scope, false),
        scalaxb.toXML[scalaxb.error.types.Description2](__obj.Description, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Description"), __scope, false))

  }

  trait DefaultTypesDocumentReferencesFormat extends scalaxb.ElemNameParser[scalaxb.error.types.DocumentReferences] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.DocumentReferences] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Reference")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.DocumentReferences(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Reference](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.DocumentReferences, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Reference flatMap { scalaxb.toXML[scalaxb.error.types.Reference](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Reference"), __scope, false) })

  }

  trait DefaultTypesNameFormat extends scalaxb.XMLFormat[scalaxb.error.types.Name] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Name] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Name] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Name(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Name, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Name, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesOrganizationFormat extends scalaxb.XMLFormat[scalaxb.error.types.Organization] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Organization] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Organization] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Organization(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Organization, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Organization, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesDescription3Format extends scalaxb.XMLFormat[scalaxb.error.types.Description3] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Description3] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Description3] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Description3(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Description3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Description3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesAcknowledgmentFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Acknowledgment] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Acknowledgment] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Name")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Organization")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Description")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "URL")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ⇒
            scalaxb.error.types.Acknowledgment(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Name](_, scalaxb.ElemName(node) :: stack) },
              p2.toSeq map { scalaxb.fromXML[scalaxb.error.types.Organization](_, scalaxb.ElemName(node) :: stack) },
              p3.headOption map { scalaxb.fromXML[scalaxb.error.types.Description3](_, scalaxb.ElemName(node) :: stack) },
              p4.toSeq map { scalaxb.fromXML[java.net.URI](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.Acknowledgment, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.Name flatMap { scalaxb.toXML[scalaxb.error.types.Name](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Name"), __scope, false) },
        __obj.Organization flatMap { scalaxb.toXML[scalaxb.error.types.Organization](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Organization"), __scope, false) },
        __obj.Description map { scalaxb.toXML[scalaxb.error.types.Description3](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Description"), __scope, false) } getOrElse { Nil },
        __obj.URL flatMap { scalaxb.toXML[java.net.URI](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("URL"), __scope, false) })

  }

  trait DefaultTypesAcknowledgmentsFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Acknowledgments] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Acknowledgments] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Acknowledgment")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.Acknowledgments(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Acknowledgment](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.Acknowledgments, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Acknowledgment flatMap { scalaxb.toXML[scalaxb.error.types.Acknowledgment](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Acknowledgment"), __scope, false) })

  }

  trait DefaultTypesCvrfdocFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Cvrfdoc] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/cvrf/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Cvrfdoc] =
      phrase((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "DocumentTitle")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "DocumentType")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "DocumentPublisher")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "DocumentTracking")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "DocumentNotes")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "DocumentDistribution")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "AggregateSeverity")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "DocumentReferences")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), "Acknowledgments")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "ProductTree")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Vulnerability")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ⇒
            scalaxb.error.types.Cvrfdoc(scalaxb.fromXML[scalaxb.error.types.DocumentTitle](p1, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[scalaxb.error.types.DocumentType](p2, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[scalaxb.error.types.DocumentPublisher](p3, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[scalaxb.error.types.DocumentTracking](p4, scalaxb.ElemName(node) :: stack),
              p5.headOption map { scalaxb.fromXML[scalaxb.error.types.DocumentNotes](_, scalaxb.ElemName(node) :: stack) },
              p6.headOption map { scalaxb.fromXML[scalaxb.error.types.DocumentDistribution](_, scalaxb.ElemName(node) :: stack) },
              p7.headOption map { scalaxb.fromXML[scalaxb.error.types.AggregateSeverity](_, scalaxb.ElemName(node) :: stack) },
              p8.headOption map { scalaxb.fromXML[scalaxb.error.types.DocumentReferences](_, scalaxb.ElemName(node) :: stack) },
              p9.headOption map { scalaxb.fromXML[scalaxb.error.types.Acknowledgments](_, scalaxb.ElemName(node) :: stack) },
              p10.headOption map { scalaxb.fromXML[scalaxb.error.types.ProductTree](_, scalaxb.ElemName(node) :: stack) },
              p11.toSeq map { scalaxb.fromXML[scalaxb.error.types.Vulnerability](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.Cvrfdoc, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[scalaxb.error.types.DocumentTitle](__obj.DocumentTitle, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("DocumentTitle"), __scope, false),
        scalaxb.toXML[scalaxb.error.types.DocumentType](__obj.DocumentType, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("DocumentType"), __scope, false),
        scalaxb.toXML[scalaxb.error.types.DocumentPublisher](__obj.DocumentPublisher, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("DocumentPublisher"), __scope, false),
        scalaxb.toXML[scalaxb.error.types.DocumentTracking](__obj.DocumentTracking, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("DocumentTracking"), __scope, false),
        __obj.DocumentNotes map { scalaxb.toXML[scalaxb.error.types.DocumentNotes](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("DocumentNotes"), __scope, false) } getOrElse { Nil },
        __obj.DocumentDistribution map { scalaxb.toXML[scalaxb.error.types.DocumentDistribution](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("DocumentDistribution"), __scope, false) } getOrElse { Nil },
        __obj.AggregateSeverity map { scalaxb.toXML[scalaxb.error.types.AggregateSeverity](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("AggregateSeverity"), __scope, false) } getOrElse { Nil },
        __obj.DocumentReferences map { scalaxb.toXML[scalaxb.error.types.DocumentReferences](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("DocumentReferences"), __scope, false) } getOrElse { Nil },
        __obj.Acknowledgments map { scalaxb.toXML[scalaxb.error.types.Acknowledgments](_, Some("http://www.icasi.org/CVRF/schema/cvrf/1.1"), Some("Acknowledgments"), __scope, false) } getOrElse { Nil },
        __obj.ProductTree map { scalaxb.toXML[scalaxb.error.types.ProductTree](_, Some("http://www.icasi.org/CVRF/schema/prod/1.1"), Some("ProductTree"), __scope, false) } getOrElse { Nil },
        __obj.Vulnerability flatMap { scalaxb.toXML[scalaxb.error.types.Vulnerability](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Vulnerability"), __scope, false) })

  }

  def buildTypesAccessComplexityEnumTypeFormat = new DefaultTypesAccessComplexityEnumTypeFormat {}
  trait DefaultTypesAccessComplexityEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.AccessComplexityEnumType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.AccessComplexityEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.AccessComplexityEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.AccessComplexityEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.AccessComplexityEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesAccessVectorEnumTypeFormat = new DefaultTypesAccessVectorEnumTypeFormat {}
  trait DefaultTypesAccessVectorEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.AccessVectorEnumType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.AccessVectorEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.AccessVectorEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.AccessVectorEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.AccessVectorEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesCiaRequirementEnumTypeFormat = new DefaultTypesCiaRequirementEnumTypeFormat {}
  trait DefaultTypesCiaRequirementEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.CiaRequirementEnumType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CiaRequirementEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.CiaRequirementEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.CiaRequirementEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.CiaRequirementEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesCollateralDamagePotentialEnumTypeFormat = new DefaultTypesCollateralDamagePotentialEnumTypeFormat {}
  trait DefaultTypesCollateralDamagePotentialEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.CollateralDamagePotentialEnumType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CollateralDamagePotentialEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.CollateralDamagePotentialEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.CollateralDamagePotentialEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.CollateralDamagePotentialEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesTargetDistributionEnumTypeFormat = new DefaultTypesTargetDistributionEnumTypeFormat {}
  trait DefaultTypesTargetDistributionEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.TargetDistributionEnumType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.TargetDistributionEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.TargetDistributionEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.TargetDistributionEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.TargetDistributionEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesCiaEnumTypeFormat = new DefaultTypesCiaEnumTypeFormat {}
  trait DefaultTypesCiaEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.CiaEnumType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CiaEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.CiaEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.CiaEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.CiaEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesAuthenticationEnumTypeFormat = new DefaultTypesAuthenticationEnumTypeFormat {}
  trait DefaultTypesAuthenticationEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.AuthenticationEnumType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.AuthenticationEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.AuthenticationEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.AuthenticationEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.AuthenticationEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesRemediationLevelEnumTypeFormat = new DefaultTypesRemediationLevelEnumTypeFormat {}
  trait DefaultTypesRemediationLevelEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.RemediationLevelEnumType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.RemediationLevelEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.RemediationLevelEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.RemediationLevelEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.RemediationLevelEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesConfidenceEnumTypeFormat = new DefaultTypesConfidenceEnumTypeFormat {}
  trait DefaultTypesConfidenceEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.ConfidenceEnumType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.ConfidenceEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.ConfidenceEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.ConfidenceEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.ConfidenceEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesExploitabilityEnumTypeFormat = new DefaultTypesExploitabilityEnumTypeFormat {}
  trait DefaultTypesExploitabilityEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.ExploitabilityEnumType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.ExploitabilityEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.ExploitabilityEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.ExploitabilityEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.ExploitabilityEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultTypesAccessComplexityTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.AccessComplexityType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.AccessComplexityType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.AccessComplexityType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.AccessComplexityType(scalaxb.fromXML[scalaxb.error.types.AccessComplexityEnumType](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@approximated").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@approximated" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.AccessComplexityType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@approximated", _) ⇒ if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
        case (key, x)             ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.AccessComplexityType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesAccessVectorTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.AccessVectorType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.AccessVectorType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.AccessVectorType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.AccessVectorType(scalaxb.fromXML[scalaxb.error.types.AccessVectorEnumType](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@approximated").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@approximated" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.AccessVectorType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@approximated", _) ⇒ if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
        case (key, x)             ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.AccessVectorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesCiaRequirementTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.CiaRequirementType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.CiaRequirementType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CiaRequirementType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.CiaRequirementType(scalaxb.fromXML[scalaxb.error.types.CiaRequirementEnumType](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@approximated").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@approximated" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.CiaRequirementType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@approximated", _) ⇒ if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
        case (key, x)             ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.CiaRequirementType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesCollateralDamagePotentialTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.CollateralDamagePotentialType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.CollateralDamagePotentialType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CollateralDamagePotentialType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.CollateralDamagePotentialType(scalaxb.fromXML[scalaxb.error.types.CollateralDamagePotentialEnumType](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@approximated").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@approximated" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.CollateralDamagePotentialType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@approximated", _) ⇒ if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
        case (key, x)             ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.CollateralDamagePotentialType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesTargetDistributionTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.TargetDistributionType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.TargetDistributionType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.TargetDistributionType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.TargetDistributionType(scalaxb.fromXML[scalaxb.error.types.TargetDistributionEnumType](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@approximated").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@approximated" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.TargetDistributionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@approximated", _) ⇒ if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
        case (key, x)             ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.TargetDistributionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesCiaTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.CiaType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.CiaType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CiaType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.CiaType(scalaxb.fromXML[scalaxb.error.types.CiaEnumType](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@approximated").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@approximated" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.CiaType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@approximated", _) ⇒ if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
        case (key, x)             ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.CiaType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesAuthenticationTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.AuthenticationType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.AuthenticationType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.AuthenticationType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.AuthenticationType(scalaxb.fromXML[scalaxb.error.types.AuthenticationEnumType](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@approximated").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@approximated" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.AuthenticationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@approximated", _) ⇒ if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
        case (key, x)             ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.AuthenticationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesRemediationLevelTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.RemediationLevelType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.RemediationLevelType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.RemediationLevelType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.RemediationLevelType(scalaxb.fromXML[scalaxb.error.types.RemediationLevelEnumType](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@approximated").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@approximated" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.RemediationLevelType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@approximated", _) ⇒ if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
        case (key, x)             ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.RemediationLevelType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesConfidenceTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.ConfidenceType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.ConfidenceType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.ConfidenceType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.ConfidenceType(scalaxb.fromXML[scalaxb.error.types.ConfidenceEnumType](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@approximated").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@approximated" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.ConfidenceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@approximated", _) ⇒ if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
        case (key, x)             ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.ConfidenceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesExploitabilityTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.ExploitabilityType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.ExploitabilityType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.ExploitabilityType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.ExploitabilityType(scalaxb.fromXML[scalaxb.error.types.ExploitabilityEnumType](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@approximated").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@approximated" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.ExploitabilityType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@approximated", _) ⇒ if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
        case (key, x)             ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.ExploitabilityType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesCvssTypableFormat extends scalaxb.XMLFormat[scalaxb.error.types.CvssTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CvssTypable] = seq match {
      case node: scala.xml.Node ⇒
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("cvssImpactType")) ⇒ Right(scalaxb.fromXML[scalaxb.error.types.CvssImpactType](node, stack))
          case _ ⇒ Right(scalaxb.fromXML[scalaxb.error.types.CvssType](node, stack))
        }
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def writes(__obj: scalaxb.error.types.CvssTypable, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: scalaxb.error.types.CvssImpactType ⇒ scalaxb.toXML[scalaxb.error.types.CvssImpactType](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.CvssType       ⇒ scalaxb.toXML[scalaxb.error.types.CvssType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultTypesCvssTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.CvssType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    override def typeName: Option[String] = Some("cvssType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.CvssType] =
      phrase(safeRep(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "base_metrics")) ~
        safeRep(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "environmental_metrics")) ~
        safeRep(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "temporal_metrics")) ^^
        {
          case p1 ~ p2 ~ p3 ⇒
            scalaxb.error.types.CvssType(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.BaseMetricsType](_, scalaxb.ElemName(node) :: stack) },
              p2.toSeq map { scalaxb.fromXML[scalaxb.error.types.EnvironmentalMetricsType](_, scalaxb.ElemName(node) :: stack) },
              p3.toSeq map { scalaxb.fromXML[scalaxb.error.types.TemporalMetricsType](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.CvssType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.base_metrics flatMap { scalaxb.toXML[scalaxb.error.types.BaseMetricsType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("base_metrics"), __scope, false) },
        __obj.environmental_metrics flatMap { scalaxb.toXML[scalaxb.error.types.EnvironmentalMetricsType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("environmental_metrics"), __scope, false) },
        __obj.temporal_metrics flatMap { scalaxb.toXML[scalaxb.error.types.TemporalMetricsType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("temporal_metrics"), __scope, false) })

  }

  trait DefaultTypesCvssImpactTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.CvssImpactType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    override def typeName: Option[String] = Some("cvssImpactType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.CvssImpactType] =
      phrase(safeRep(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "base_metrics")) ~
        safeRep(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "environmental_metrics")) ~
        safeRep(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "temporal_metrics")) ^^
        {
          case p1 ~ p2 ~ p3 ⇒
            scalaxb.error.types.CvssImpactType(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.BaseMetricsType](_, scalaxb.ElemName(node) :: stack) },
              p2.toSeq map { scalaxb.fromXML[scalaxb.error.types.EnvironmentalMetricsType](_, scalaxb.ElemName(node) :: stack) },
              p3.toSeq map { scalaxb.fromXML[scalaxb.error.types.TemporalMetricsType](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.CvssImpactType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.base_metrics flatMap { scalaxb.toXML[scalaxb.error.types.BaseMetricsType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("base_metrics"), __scope, false) },
        __obj.environmental_metrics flatMap { scalaxb.toXML[scalaxb.error.types.EnvironmentalMetricsType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("environmental_metrics"), __scope, false) },
        __obj.temporal_metrics flatMap { scalaxb.toXML[scalaxb.error.types.TemporalMetricsType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("temporal_metrics"), __scope, false) })

  }

  trait DefaultTypesCvssImpactBaseTypableFormat extends scalaxb.XMLFormat[scalaxb.error.types.CvssImpactBaseTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CvssImpactBaseTypable] = seq match {
      case node: scala.xml.Node ⇒
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("cvssImpactTemporalType")) ⇒ Right(scalaxb.fromXML[scalaxb.error.types.CvssImpactTemporalTypable](node, stack))
          case (Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("cvssImpactEnvironmentalType")) ⇒ Right(scalaxb.fromXML[scalaxb.error.types.CvssImpactEnvironmentalType](node, stack))
          case _ ⇒ Right(scalaxb.fromXML[scalaxb.error.types.CvssImpactBaseType](node, stack))
        }
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def writes(__obj: scalaxb.error.types.CvssImpactBaseTypable, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: scalaxb.error.types.CvssImpactTemporalTypable ⇒ scalaxb.toXML[scalaxb.error.types.CvssImpactTemporalTypable](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.CvssImpactBaseType        ⇒ scalaxb.toXML[scalaxb.error.types.CvssImpactBaseType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultTypesCvssImpactBaseTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.CvssImpactBaseType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    override def typeName: Option[String] = Some("cvssImpactBaseType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.CvssImpactBaseType] =
      phrase((scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "base_metrics")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.CvssImpactBaseType(scalaxb.fromXML[scalaxb.error.types.BaseMetricsType](p1, scalaxb.ElemName(node) :: stack))
        })

    def writesChildNodes(__obj: scalaxb.error.types.CvssImpactBaseType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[scalaxb.error.types.BaseMetricsType](__obj.base_metrics, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("base_metrics"), __scope, false))

  }

  trait DefaultTypesCvssImpactTemporalTypableFormat extends scalaxb.XMLFormat[scalaxb.error.types.CvssImpactTemporalTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CvssImpactTemporalTypable] = seq match {
      case node: scala.xml.Node ⇒
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("cvssImpactEnvironmentalType")) ⇒ Right(scalaxb.fromXML[scalaxb.error.types.CvssImpactEnvironmentalType](node, stack))
          case _ ⇒ Right(scalaxb.fromXML[scalaxb.error.types.CvssImpactTemporalType](node, stack))
        }
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def writes(__obj: scalaxb.error.types.CvssImpactTemporalTypable, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: scalaxb.error.types.CvssImpactEnvironmentalType ⇒ scalaxb.toXML[scalaxb.error.types.CvssImpactEnvironmentalType](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.CvssImpactTemporalType      ⇒ scalaxb.toXML[scalaxb.error.types.CvssImpactTemporalType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultTypesCvssImpactTemporalTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.CvssImpactTemporalType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    override def typeName: Option[String] = Some("cvssImpactTemporalType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.CvssImpactTemporalType] =
      phrase((scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "base_metrics")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "temporal_metrics")) ^^
        {
          case p1 ~ p2 ⇒
            scalaxb.error.types.CvssImpactTemporalType(scalaxb.fromXML[scalaxb.error.types.BaseMetricsType](p1, scalaxb.ElemName(node) :: stack),
              p2.headOption map { scalaxb.fromXML[scalaxb.error.types.TemporalMetricsType](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.CvssImpactTemporalType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[scalaxb.error.types.BaseMetricsType](__obj.base_metrics, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("base_metrics"), __scope, false),
        __obj.temporal_metrics map { scalaxb.toXML[scalaxb.error.types.TemporalMetricsType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("temporal_metrics"), __scope, false) } getOrElse { Nil })

  }

  trait DefaultTypesCvssImpactEnvironmentalTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.CvssImpactEnvironmentalType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    override def typeName: Option[String] = Some("cvssImpactEnvironmentalType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.CvssImpactEnvironmentalType] =
      phrase((scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "base_metrics")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "temporal_metrics")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "environmental_metrics")) ^^
        {
          case p1 ~ p2 ~ p3 ⇒
            scalaxb.error.types.CvssImpactEnvironmentalType(scalaxb.fromXML[scalaxb.error.types.BaseMetricsType](p1, scalaxb.ElemName(node) :: stack),
              p2.headOption map { scalaxb.fromXML[scalaxb.error.types.TemporalMetricsType](_, scalaxb.ElemName(node) :: stack) },
              p3.headOption map { scalaxb.fromXML[scalaxb.error.types.EnvironmentalMetricsType](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.CvssImpactEnvironmentalType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[scalaxb.error.types.BaseMetricsType](__obj.base_metrics, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("base_metrics"), __scope, false),
        __obj.temporal_metrics map { scalaxb.toXML[scalaxb.error.types.TemporalMetricsType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("temporal_metrics"), __scope, false) } getOrElse { Nil },
        __obj.environmental_metrics map { scalaxb.toXML[scalaxb.error.types.EnvironmentalMetricsType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("environmental_metrics"), __scope, false) } getOrElse { Nil })

  }

  trait DefaultTypesMetricsTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.MetricsType] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.MetricsType] = seq match {
      case node: scala.xml.Node ⇒
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("environmentalMetricsType")) ⇒ Right(scalaxb.fromXML[scalaxb.error.types.EnvironmentalMetricsType](node, stack))
          case (Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("baseMetricsType")) ⇒ Right(scalaxb.fromXML[scalaxb.error.types.BaseMetricsType](node, stack))
          case (Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("temporalMetricsType")) ⇒ Right(scalaxb.fromXML[scalaxb.error.types.TemporalMetricsType](node, stack))
          case x ⇒ Left("Unknown type: " + x)
        }
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def writes(__obj: scalaxb.error.types.MetricsType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: scalaxb.error.types.EnvironmentalMetricsType ⇒ scalaxb.toXML[scalaxb.error.types.EnvironmentalMetricsType](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.BaseMetricsType ⇒ scalaxb.toXML[scalaxb.error.types.BaseMetricsType](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.TemporalMetricsType ⇒ scalaxb.toXML[scalaxb.error.types.TemporalMetricsType](x, __namespace, __elementLabel, __scope, true)
      case _ ⇒ sys.error("Unknown type: " + __obj)
    }
  }

  trait DefaultTypesBaseMetricsTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.BaseMetricsType] with TypesBaseVectorsGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    override def typeName: Option[String] = Some("baseMetricsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.BaseMetricsType] =
      phrase(opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "score")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "exploit-subscore")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "impact-subscore")) ~
        (parseBaseVectorsGroupGroup(node, scalaxb.ElemName(node) :: stack)) ~
        (scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "source")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "generated-on-datetime")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ⇒
            scalaxb.error.types.BaseMetricsType(p1.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
              p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
              p3.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
              p4,
              scalaxb.fromXML[java.net.URI](p5, scalaxb.ElemName(node) :: stack),
              p6.headOption map { scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@upgraded-from-version").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@upgraded-from-version" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.BaseMetricsType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@upgraded-from-version", _) ⇒ __obj.upgradedu45fromu45version foreach { x ⇒ attr = scala.xml.Attribute(null, "upgraded-from-version", x.toString, attr) }
        case (key, x)                      ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.BaseMetricsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.score map { scalaxb.toXML[BigDecimal](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("score"), __scope, false) } getOrElse { Nil },
        __obj.exploitu45subscore map { scalaxb.toXML[BigDecimal](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("exploit-subscore"), __scope, false) } getOrElse { Nil },
        __obj.impactu45subscore map { scalaxb.toXML[BigDecimal](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("impact-subscore"), __scope, false) } getOrElse { Nil },
        scalaxb.toXML[scalaxb.error.types.BaseVectorsGroupSequence](__obj.baseVectorsGroupSequence5, None, Some("baseVectorsGroupSequence5"), __scope, false),
        scalaxb.toXML[java.net.URI](__obj.source, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("source"), __scope, false),
        __obj.generatedu45onu45datetime map { scalaxb.toXML[javax.xml.datatype.XMLGregorianCalendar](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("generated-on-datetime"), __scope, false) } getOrElse { Nil })

  }

  trait DefaultTypesEnvironmentalMetricsTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.EnvironmentalMetricsType] with TypesEnvironmentalVectorsGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    override def typeName: Option[String] = Some("environmentalMetricsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.EnvironmentalMetricsType] =
      phrase(opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "score")) ~
        (parseEnvironmentalVectorsGroupGroup(node, scalaxb.ElemName(node) :: stack)) ~
        (scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "source")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "generated-on-datetime")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ⇒
            scalaxb.error.types.EnvironmentalMetricsType(p1.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
              p2,
              scalaxb.fromXML[java.net.URI](p3, scalaxb.ElemName(node) :: stack),
              p4.headOption map { scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@upgraded-from-version").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@upgraded-from-version" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.EnvironmentalMetricsType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@upgraded-from-version", _) ⇒ __obj.upgradedu45fromu45version foreach { x ⇒ attr = scala.xml.Attribute(null, "upgraded-from-version", x.toString, attr) }
        case (key, x)                      ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.EnvironmentalMetricsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.score map { scalaxb.toXML[BigDecimal](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("score"), __scope, false) } getOrElse { Nil },
        scalaxb.toXML[scalaxb.error.types.EnvironmentalVectorsGroupSequence](__obj.environmentalVectorsGroupSequence3, None, Some("environmentalVectorsGroupSequence3"), __scope, false),
        scalaxb.toXML[java.net.URI](__obj.source, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("source"), __scope, false),
        __obj.generatedu45onu45datetime map { scalaxb.toXML[javax.xml.datatype.XMLGregorianCalendar](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("generated-on-datetime"), __scope, false) } getOrElse { Nil })

  }

  trait DefaultTypesTemporalMetricsTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.TemporalMetricsType] with TypesTemporalVectorsGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    override def typeName: Option[String] = Some("temporalMetricsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.TemporalMetricsType] =
      phrase(opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "score")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "temporal-multiplier")) ~
        (parseTemporalVectorsGroupGroup(node, scalaxb.ElemName(node) :: stack)) ~
        (scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "source")) ~
        (scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "generated-on-datetime")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ⇒
            scalaxb.error.types.TemporalMetricsType(p1.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
              p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
              p3,
              scalaxb.fromXML[java.net.URI](p4, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](p5, scalaxb.ElemName(node) :: stack),
              scala.collection.immutable.ListMap(List(
                (node \ "@upgraded-from-version").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@upgraded-from-version" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.TemporalMetricsType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@upgraded-from-version", _) ⇒ __obj.upgradedu45fromu45version foreach { x ⇒ attr = scala.xml.Attribute(null, "upgraded-from-version", x.toString, attr) }
        case (key, x)                      ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.TemporalMetricsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.score map { scalaxb.toXML[BigDecimal](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("score"), __scope, false) } getOrElse { Nil },
        __obj.temporalu45multiplier map { scalaxb.toXML[BigDecimal](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("temporal-multiplier"), __scope, false) } getOrElse { Nil },
        scalaxb.toXML[scalaxb.error.types.TemporalVectorsGroupSequence](__obj.temporalVectorsGroupSequence4, None, Some("temporalVectorsGroupSequence4"), __scope, false),
        scalaxb.toXML[java.net.URI](__obj.source, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("source"), __scope, false),
        scalaxb.toXML[javax.xml.datatype.XMLGregorianCalendar](__obj.generatedu45onu45datetime, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("generated-on-datetime"), __scope, false))

  }

  trait TypesTemporalVectorsCriteriaGroupGroupFormat extends scalaxb.AnyElemNameParser {
    def parseTemporalVectorsCriteriaGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.TemporalVectorsCriteriaGroupSequence] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "exploitability")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "remediation-level")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "report-confidence"))) ^^
        {
          case p1 ~ p2 ~ p3 ⇒ scalaxb.error.types.TemporalVectorsCriteriaGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.ExploitabilityEnumType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.RemediationLevelEnumType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.ConfidenceEnumType](_, scalaxb.ElemName(node) :: stack) })
        })

    def parseTemporalVectorsCriteriaGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "exploitability")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "remediation-level")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "report-confidence"))) ^^
        {
          case p1 ~ p2 ~ p3 ⇒ scalaxb.DataRecord(scalaxb.error.types.TemporalVectorsCriteriaGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.ExploitabilityEnumType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.RemediationLevelEnumType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.ConfidenceEnumType](_, scalaxb.ElemName(node) :: stack) }))
        })

    def parsemixedTemporalVectorsCriteriaGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "exploitability")) ^^
        (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
        optTextRecord ~
        (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "remediation-level")) ^^
          (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
          optTextRecord ~
          (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "report-confidence")) ^^
            (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
            optTextRecord) ^^
            {
              case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ⇒ Seq.concat(p1.toList,
                p2.toList,
                p3.toList,
                p4.toList,
                p5.toList,
                p6.toList)
            })
  }

  trait DefaultTypesTemporalVectorsCriteriaGroupSequenceFormat extends scalaxb.XMLFormat[scalaxb.error.types.TemporalVectorsCriteriaGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.TemporalVectorsCriteriaGroupSequence] = Left("don't call me.")

    def writes(__obj: scalaxb.error.types.TemporalVectorsCriteriaGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.exploitability map { scalaxb.toXML[scalaxb.error.types.ExploitabilityEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("exploitability"), __scope, false) } getOrElse { Nil },
        __obj.remediationu45level map { scalaxb.toXML[scalaxb.error.types.RemediationLevelEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("remediation-level"), __scope, false) } getOrElse { Nil },
        __obj.reportu45confidence map { scalaxb.toXML[scalaxb.error.types.ConfidenceEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("report-confidence"), __scope, false) } getOrElse { Nil })

  }

  trait TypesBaseVectorsCriteriaGroupGroupFormat extends scalaxb.AnyElemNameParser {
    def parseBaseVectorsCriteriaGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.BaseVectorsCriteriaGroupSequence] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-vector")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-complexity")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "authentication")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-impact")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-impact")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-impact"))) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ⇒ scalaxb.error.types.BaseVectorsCriteriaGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.AccessVectorEnumType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.AccessComplexityEnumType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.AuthenticationEnumType](_, scalaxb.ElemName(node) :: stack) },
            p4.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaEnumType](_, scalaxb.ElemName(node) :: stack) },
            p5.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaEnumType](_, scalaxb.ElemName(node) :: stack) },
            p6.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaEnumType](_, scalaxb.ElemName(node) :: stack) })
        })

    def parseBaseVectorsCriteriaGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-vector")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-complexity")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "authentication")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-impact")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-impact")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-impact"))) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ⇒ scalaxb.DataRecord(scalaxb.error.types.BaseVectorsCriteriaGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.AccessVectorEnumType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.AccessComplexityEnumType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.AuthenticationEnumType](_, scalaxb.ElemName(node) :: stack) },
            p4.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaEnumType](_, scalaxb.ElemName(node) :: stack) },
            p5.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaEnumType](_, scalaxb.ElemName(node) :: stack) },
            p6.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaEnumType](_, scalaxb.ElemName(node) :: stack) }))
        })

    def parsemixedBaseVectorsCriteriaGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-vector")) ^^
        (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
        optTextRecord ~
        (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-complexity")) ^^
          (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
          optTextRecord ~
          (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "authentication")) ^^
            (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
            optTextRecord ~
            (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-impact")) ^^
              (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
              optTextRecord ~
              (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-impact")) ^^
                (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
                optTextRecord ~
                (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-impact")) ^^
                  (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
                  optTextRecord) ^^
                  {
                    case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ⇒ Seq.concat(p1.toList,
                      p2.toList,
                      p3.toList,
                      p4.toList,
                      p5.toList,
                      p6.toList,
                      p7.toList,
                      p8.toList,
                      p9.toList,
                      p10.toList,
                      p11.toList,
                      p12.toList)
                  })
  }

  trait DefaultTypesBaseVectorsCriteriaGroupSequenceFormat extends scalaxb.XMLFormat[scalaxb.error.types.BaseVectorsCriteriaGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.BaseVectorsCriteriaGroupSequence] = Left("don't call me.")

    def writes(__obj: scalaxb.error.types.BaseVectorsCriteriaGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.accessu45vector map { scalaxb.toXML[scalaxb.error.types.AccessVectorEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("access-vector"), __scope, false) } getOrElse { Nil },
        __obj.accessu45complexity map { scalaxb.toXML[scalaxb.error.types.AccessComplexityEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("access-complexity"), __scope, false) } getOrElse { Nil },
        __obj.authentication map { scalaxb.toXML[scalaxb.error.types.AuthenticationEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("authentication"), __scope, false) } getOrElse { Nil },
        __obj.confidentialityu45impact map { scalaxb.toXML[scalaxb.error.types.CiaEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("confidentiality-impact"), __scope, false) } getOrElse { Nil },
        __obj.integrityu45impact map { scalaxb.toXML[scalaxb.error.types.CiaEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("integrity-impact"), __scope, false) } getOrElse { Nil },
        __obj.availabilityu45impact map { scalaxb.toXML[scalaxb.error.types.CiaEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("availability-impact"), __scope, false) } getOrElse { Nil })

  }

  trait TypesEnvironmentalVectorsGroupGroupFormat extends scalaxb.AnyElemNameParser {
    def parseEnvironmentalVectorsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.EnvironmentalVectorsGroupSequence] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "collateral-damage-potential")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "target-distribution")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-requirement")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-requirement")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-requirement"))) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ⇒ scalaxb.error.types.EnvironmentalVectorsGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.CollateralDamagePotentialType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.TargetDistributionType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementType](_, scalaxb.ElemName(node) :: stack) },
            p4.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementType](_, scalaxb.ElemName(node) :: stack) },
            p5.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementType](_, scalaxb.ElemName(node) :: stack) })
        })

    def parseEnvironmentalVectorsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "collateral-damage-potential")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "target-distribution")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-requirement")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-requirement")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-requirement"))) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ⇒ scalaxb.DataRecord(scalaxb.error.types.EnvironmentalVectorsGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.CollateralDamagePotentialType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.TargetDistributionType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementType](_, scalaxb.ElemName(node) :: stack) },
            p4.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementType](_, scalaxb.ElemName(node) :: stack) },
            p5.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementType](_, scalaxb.ElemName(node) :: stack) }))
        })

    def parsemixedEnvironmentalVectorsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "collateral-damage-potential")) ^^
        (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.CollateralDamagePotentialType](x, scalaxb.ElemName(node) :: stack)) })) ~
        optTextRecord ~
        (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "target-distribution")) ^^
          (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.TargetDistributionType](x, scalaxb.ElemName(node) :: stack)) })) ~
          optTextRecord ~
          (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-requirement")) ^^
            (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.CiaRequirementType](x, scalaxb.ElemName(node) :: stack)) })) ~
            optTextRecord ~
            (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-requirement")) ^^
              (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.CiaRequirementType](x, scalaxb.ElemName(node) :: stack)) })) ~
              optTextRecord ~
              (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-requirement")) ^^
                (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.CiaRequirementType](x, scalaxb.ElemName(node) :: stack)) })) ~
                optTextRecord) ^^
                {
                  case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ⇒ Seq.concat(p1.toList,
                    p2.toList,
                    p3.toList,
                    p4.toList,
                    p5.toList,
                    p6.toList,
                    p7.toList,
                    p8.toList,
                    p9.toList,
                    p10.toList)
                })
  }

  trait DefaultTypesEnvironmentalVectorsGroupSequenceFormat extends scalaxb.XMLFormat[scalaxb.error.types.EnvironmentalVectorsGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.EnvironmentalVectorsGroupSequence] = Left("don't call me.")

    def writes(__obj: scalaxb.error.types.EnvironmentalVectorsGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.collateralu45damageu45potential map { scalaxb.toXML[scalaxb.error.types.CollateralDamagePotentialType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("collateral-damage-potential"), __scope, false) } getOrElse { Nil },
        __obj.targetu45distribution map { scalaxb.toXML[scalaxb.error.types.TargetDistributionType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("target-distribution"), __scope, false) } getOrElse { Nil },
        __obj.confidentialityu45requirement map { scalaxb.toXML[scalaxb.error.types.CiaRequirementType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("confidentiality-requirement"), __scope, false) } getOrElse { Nil },
        __obj.integrityu45requirement map { scalaxb.toXML[scalaxb.error.types.CiaRequirementType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("integrity-requirement"), __scope, false) } getOrElse { Nil },
        __obj.availabilityu45requirement map { scalaxb.toXML[scalaxb.error.types.CiaRequirementType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("availability-requirement"), __scope, false) } getOrElse { Nil })

  }

  trait TypesBaseVectorsGroupGroupFormat extends scalaxb.AnyElemNameParser {
    def parseBaseVectorsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.BaseVectorsGroupSequence] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-vector")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-complexity")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "authentication")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-impact")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-impact")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-impact"))) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ⇒ scalaxb.error.types.BaseVectorsGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.AccessVectorType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.AccessComplexityType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.AuthenticationType](_, scalaxb.ElemName(node) :: stack) },
            p4.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaType](_, scalaxb.ElemName(node) :: stack) },
            p5.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaType](_, scalaxb.ElemName(node) :: stack) },
            p6.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaType](_, scalaxb.ElemName(node) :: stack) })
        })

    def parseBaseVectorsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-vector")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-complexity")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "authentication")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-impact")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-impact")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-impact"))) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ⇒ scalaxb.DataRecord(scalaxb.error.types.BaseVectorsGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.AccessVectorType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.AccessComplexityType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.AuthenticationType](_, scalaxb.ElemName(node) :: stack) },
            p4.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaType](_, scalaxb.ElemName(node) :: stack) },
            p5.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaType](_, scalaxb.ElemName(node) :: stack) },
            p6.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaType](_, scalaxb.ElemName(node) :: stack) }))
        })

    def parsemixedBaseVectorsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-vector")) ^^
        (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.AccessVectorType](x, scalaxb.ElemName(node) :: stack)) })) ~
        optTextRecord ~
        (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "access-complexity")) ^^
          (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.AccessComplexityType](x, scalaxb.ElemName(node) :: stack)) })) ~
          optTextRecord ~
          (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "authentication")) ^^
            (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.AuthenticationType](x, scalaxb.ElemName(node) :: stack)) })) ~
            optTextRecord ~
            (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-impact")) ^^
              (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.CiaType](x, scalaxb.ElemName(node) :: stack)) })) ~
              optTextRecord ~
              (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-impact")) ^^
                (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.CiaType](x, scalaxb.ElemName(node) :: stack)) })) ~
                optTextRecord ~
                (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-impact")) ^^
                  (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.CiaType](x, scalaxb.ElemName(node) :: stack)) })) ~
                  optTextRecord) ^^
                  {
                    case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ⇒ Seq.concat(p1.toList,
                      p2.toList,
                      p3.toList,
                      p4.toList,
                      p5.toList,
                      p6.toList,
                      p7.toList,
                      p8.toList,
                      p9.toList,
                      p10.toList,
                      p11.toList,
                      p12.toList)
                  })
  }

  trait DefaultTypesBaseVectorsGroupSequenceFormat extends scalaxb.XMLFormat[scalaxb.error.types.BaseVectorsGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.BaseVectorsGroupSequence] = Left("don't call me.")

    def writes(__obj: scalaxb.error.types.BaseVectorsGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.accessu45vector map { scalaxb.toXML[scalaxb.error.types.AccessVectorType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("access-vector"), __scope, false) } getOrElse { Nil },
        __obj.accessu45complexity map { scalaxb.toXML[scalaxb.error.types.AccessComplexityType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("access-complexity"), __scope, false) } getOrElse { Nil },
        __obj.authentication map { scalaxb.toXML[scalaxb.error.types.AuthenticationType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("authentication"), __scope, false) } getOrElse { Nil },
        __obj.confidentialityu45impact map { scalaxb.toXML[scalaxb.error.types.CiaType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("confidentiality-impact"), __scope, false) } getOrElse { Nil },
        __obj.integrityu45impact map { scalaxb.toXML[scalaxb.error.types.CiaType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("integrity-impact"), __scope, false) } getOrElse { Nil },
        __obj.availabilityu45impact map { scalaxb.toXML[scalaxb.error.types.CiaType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("availability-impact"), __scope, false) } getOrElse { Nil })

  }

  trait TypesTemporalVectorsGroupGroupFormat extends scalaxb.AnyElemNameParser {
    def parseTemporalVectorsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.TemporalVectorsGroupSequence] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "exploitability")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "remediation-level")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "report-confidence"))) ^^
        {
          case p1 ~ p2 ~ p3 ⇒ scalaxb.error.types.TemporalVectorsGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.ExploitabilityType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.RemediationLevelType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.ConfidenceType](_, scalaxb.ElemName(node) :: stack) })
        })

    def parseTemporalVectorsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "exploitability")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "remediation-level")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "report-confidence"))) ^^
        {
          case p1 ~ p2 ~ p3 ⇒ scalaxb.DataRecord(scalaxb.error.types.TemporalVectorsGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.ExploitabilityType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.RemediationLevelType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.ConfidenceType](_, scalaxb.ElemName(node) :: stack) }))
        })

    def parsemixedTemporalVectorsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "exploitability")) ^^
        (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.ExploitabilityType](x, scalaxb.ElemName(node) :: stack)) })) ~
        optTextRecord ~
        (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "remediation-level")) ^^
          (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.RemediationLevelType](x, scalaxb.ElemName(node) :: stack)) })) ~
          optTextRecord ~
          (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "report-confidence")) ^^
            (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.ConfidenceType](x, scalaxb.ElemName(node) :: stack)) })) ~
            optTextRecord) ^^
            {
              case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ⇒ Seq.concat(p1.toList,
                p2.toList,
                p3.toList,
                p4.toList,
                p5.toList,
                p6.toList)
            })
  }

  trait DefaultTypesTemporalVectorsGroupSequenceFormat extends scalaxb.XMLFormat[scalaxb.error.types.TemporalVectorsGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.TemporalVectorsGroupSequence] = Left("don't call me.")

    def writes(__obj: scalaxb.error.types.TemporalVectorsGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.exploitability map { scalaxb.toXML[scalaxb.error.types.ExploitabilityType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("exploitability"), __scope, false) } getOrElse { Nil },
        __obj.remediationu45level map { scalaxb.toXML[scalaxb.error.types.RemediationLevelType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("remediation-level"), __scope, false) } getOrElse { Nil },
        __obj.reportu45confidence map { scalaxb.toXML[scalaxb.error.types.ConfidenceType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("report-confidence"), __scope, false) } getOrElse { Nil })

  }

  trait TypesEnvironmentalVectorsCriteriaGroupGroupFormat extends scalaxb.AnyElemNameParser {
    def parseEnvironmentalVectorsCriteriaGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.EnvironmentalVectorsCriteriaGroupSequence] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "collateral-damage-potential")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "target-distribution")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-requirement")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-requirement")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-requirement"))) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ⇒ scalaxb.error.types.EnvironmentalVectorsCriteriaGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.CollateralDamagePotentialEnumType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.TargetDistributionEnumType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementEnumType](_, scalaxb.ElemName(node) :: stack) },
            p4.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementEnumType](_, scalaxb.ElemName(node) :: stack) },
            p5.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementEnumType](_, scalaxb.ElemName(node) :: stack) })
        })

    def parseEnvironmentalVectorsCriteriaGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "collateral-damage-potential")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "target-distribution")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-requirement")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-requirement")) ~
        opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-requirement"))) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ⇒ scalaxb.DataRecord(scalaxb.error.types.EnvironmentalVectorsCriteriaGroupSequence(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.CollateralDamagePotentialEnumType](_, scalaxb.ElemName(node) :: stack) },
            p2.headOption map { scalaxb.fromXML[scalaxb.error.types.TargetDistributionEnumType](_, scalaxb.ElemName(node) :: stack) },
            p3.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementEnumType](_, scalaxb.ElemName(node) :: stack) },
            p4.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementEnumType](_, scalaxb.ElemName(node) :: stack) },
            p5.headOption map { scalaxb.fromXML[scalaxb.error.types.CiaRequirementEnumType](_, scalaxb.ElemName(node) :: stack) }))
        })

    def parsemixedEnvironmentalVectorsCriteriaGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "collateral-damage-potential")) ^^
        (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
        optTextRecord ~
        (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "target-distribution")) ^^
          (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
          optTextRecord ~
          (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "confidentiality-requirement")) ^^
            (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
            optTextRecord ~
            (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "integrity-requirement")) ^^
              (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
              optTextRecord ~
              (opt(scalaxb.ElemName(Some("http://scap.nist.gov/schema/cvss-v2/1.0"), "availability-requirement")) ^^
                (_ map { x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~
                optTextRecord) ^^
                {
                  case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ⇒ Seq.concat(p1.toList,
                    p2.toList,
                    p3.toList,
                    p4.toList,
                    p5.toList,
                    p6.toList,
                    p7.toList,
                    p8.toList,
                    p9.toList,
                    p10.toList)
                })
  }

  trait DefaultTypesEnvironmentalVectorsCriteriaGroupSequenceFormat extends scalaxb.XMLFormat[scalaxb.error.types.EnvironmentalVectorsCriteriaGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.EnvironmentalVectorsCriteriaGroupSequence] = Left("don't call me.")

    def writes(__obj: scalaxb.error.types.EnvironmentalVectorsCriteriaGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.collateralu45damageu45potential map { scalaxb.toXML[scalaxb.error.types.CollateralDamagePotentialEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("collateral-damage-potential"), __scope, false) } getOrElse { Nil },
        __obj.targetu45distribution map { scalaxb.toXML[scalaxb.error.types.TargetDistributionEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("target-distribution"), __scope, false) } getOrElse { Nil },
        __obj.confidentialityu45requirement map { scalaxb.toXML[scalaxb.error.types.CiaRequirementEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("confidentiality-requirement"), __scope, false) } getOrElse { Nil },
        __obj.integrityu45requirement map { scalaxb.toXML[scalaxb.error.types.CiaRequirementEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("integrity-requirement"), __scope, false) } getOrElse { Nil },
        __obj.availabilityu45requirement map { scalaxb.toXML[scalaxb.error.types.CiaRequirementEnumType](_, Some("http://scap.nist.gov/schema/cvss-v2/1.0"), Some("availability-requirement"), __scope, false) } getOrElse { Nil })

  }

  trait DefaultTypesVectorAttributeGroupFormat extends scalaxb.AttributeGroupFormat[scalaxb.error.types.VectorAttributeGroup] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/cvss-v2/1.0")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.VectorAttributeGroup] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.VectorAttributeGroup((node \ "@approximated").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) }))
      case _                    ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def toAttribute(__obj: scalaxb.error.types.VectorAttributeGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = __attr
      if (__obj.approximated.toString != "false") attr = scala.xml.Attribute(null, "approximated", __obj.approximated.toString, attr)
      attr
    }
  }

  trait DefaultTypesSimpleLiteralFormat extends scalaxb.ElemNameParser[scalaxb.error.types.SimpleLiteral] {
    val targetNamespace: Option[String] = Some("http://purl.org/dc/elements/1.1/")

    override def typeName: Option[String] = Some("SimpleLiteral")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.SimpleLiteral] =
      phrase(opt(any(_ ⇒ true)) ^^
        {
          case p1 ⇒
            scalaxb.error.types.SimpleLiteral(p1.headOption map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.SimpleLiteral, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ __obj.xmllang foreach { x ⇒ attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.SimpleLiteral, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.any map { x ⇒ scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) } getOrElse { Nil })

  }

  trait DefaultTypesElementContainerFormat extends scalaxb.ElemNameParser[scalaxb.error.types.ElementContainer] with TypesElementsGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://purl.org/dc/elements/1.1/")

    override def typeName: Option[String] = Some("elementContainer")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.ElementContainer] =
      phrase(safeRep((parseElementsGroupGroup(node, scalaxb.ElemName(node) :: stack, true))) ^^
        {
          case p1 ⇒
            scalaxb.error.types.ElementContainer(p1.toSeq: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.ElementContainer, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.elementcontaineroption flatMap { x ⇒ scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })

  }

  /**
   * This group is included as a convenience for schema authors
   * who need to refer to all the elements in the
   * http://purl.org/dc/elements/1.1/ namespace.
   *
   */
  trait TypesElementsGroupGroupFormat extends scalaxb.AnyElemNameParser {
    def parseElementsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.DataRecord[scalaxb.error.types.SimpleLiteral]] =
      (((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((scalaxb.ElemName(Some("http://purl.org/dc/elements/1.1/"), "any")) ^^
          (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.SimpleLiteral](x, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))))

    def parseElementsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[scalaxb.error.types.SimpleLiteral]] =
      (((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
        ((scalaxb.ElemName(Some("http://purl.org/dc/elements/1.1/"), "any")) ^^
          (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.SimpleLiteral](x, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) |
          ((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))))

    def parsemixedElementsGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
        optTextRecord) ^^
        { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
        optTextRecord) ^^
        {
          case p1 ~ p2 ⇒ Seq.concat(p1,
            p2.toList)
        }) |||
        (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
          optTextRecord) ^^
          { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
          optTextRecord) ^^
          {
            case p1 ~ p2 ⇒ Seq.concat(p1,
              p2.toList)
          }) |||
          (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
            optTextRecord) ^^
            { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
            optTextRecord) ^^
            {
              case p1 ~ p2 ⇒ Seq.concat(p1,
                p2.toList)
            }) |||
            (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
              optTextRecord) ^^
              { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
              optTextRecord) ^^
              {
                case p1 ~ p2 ⇒ Seq.concat(p1,
                  p2.toList)
              }) |||
              (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                optTextRecord) ^^
                { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                optTextRecord) ^^
                {
                  case p1 ~ p2 ⇒ Seq.concat(p1,
                    p2.toList)
                }) |||
                (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                  optTextRecord) ^^
                  { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                  optTextRecord) ^^
                  {
                    case p1 ~ p2 ⇒ Seq.concat(p1,
                      p2.toList)
                  }) |||
                  (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                    optTextRecord) ^^
                    { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                    optTextRecord) ^^
                    {
                      case p1 ~ p2 ⇒ Seq.concat(p1,
                        p2.toList)
                    }) |||
                    (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                      optTextRecord) ^^
                      { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                      optTextRecord) ^^
                      {
                        case p1 ~ p2 ⇒ Seq.concat(p1,
                          p2.toList)
                      }) |||
                      ((((scalaxb.ElemName(Some("http://purl.org/dc/elements/1.1/"), "any")) ^^
                        (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.SimpleLiteral](x, scalaxb.ElemName(node) :: stack)))) ~
                        optTextRecord) ^^
                        {
                          case p1 ~ p2 ⇒ Seq.concat(Seq(p1),
                            p2.toList)
                        }) |||
                        (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                          optTextRecord) ^^
                          { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                          optTextRecord) ^^
                          {
                            case p1 ~ p2 ⇒ Seq.concat(p1,
                              p2.toList)
                          }) |||
                          (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                            optTextRecord) ^^
                            { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                            optTextRecord) ^^
                            {
                              case p1 ~ p2 ⇒ Seq.concat(p1,
                                p2.toList)
                            }) |||
                            (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                              optTextRecord) ^^
                              { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                              optTextRecord) ^^
                              {
                                case p1 ~ p2 ⇒ Seq.concat(p1,
                                  p2.toList)
                              }) |||
                              (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                                optTextRecord) ^^
                                { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                                optTextRecord) ^^
                                {
                                  case p1 ~ p2 ⇒ Seq.concat(p1,
                                    p2.toList)
                                }) |||
                                (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                                  optTextRecord) ^^
                                  { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                                  optTextRecord) ^^
                                  {
                                    case p1 ~ p2 ⇒ Seq.concat(p1,
                                      p2.toList)
                                  }) |||
                                  (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                                    optTextRecord) ^^
                                    { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                                    optTextRecord) ^^
                                    {
                                      case p1 ~ p2 ⇒ Seq.concat(p1,
                                        p2.toList)
                                    }) |||
                                    (((((any(_ ⇒ true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~
                                      optTextRecord) ^^
                                      { case p1 ~ p2 ⇒ Seq.concat(Seq(p1), p2.toList) }) ~
                                      optTextRecord) ^^
                                      {
                                        case p1 ~ p2 ⇒ Seq.concat(p1,
                                          p2.toList)
                                      }))
  }

  def buildTypesBranchTypeEnumTypeFormat = new DefaultTypesBranchTypeEnumTypeFormat {}
  trait DefaultTypesBranchTypeEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.BranchTypeEnumType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/prod/1.1")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.BranchTypeEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.BranchTypeEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.BranchTypeEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.BranchTypeEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesRelationTypeEnumTypeFormat = new DefaultTypesRelationTypeEnumTypeFormat {}
  trait DefaultTypesRelationTypeEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.RelationTypeEnumType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/prod/1.1")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.RelationTypeEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.RelationTypeEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.RelationTypeEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.RelationTypeEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultTypesBranchTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.BranchType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/prod/1.1")

    override def typeName: Option[String] = Some("BranchType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.BranchType] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "FullProductName")) ^^
        (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.FullProductName](x, scalaxb.ElemName(node) :: stack)))) |
        ((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "Branch")) ^^
          (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[scalaxb.error.types.BranchType](x, scalaxb.ElemName(node) :: stack))))) ^^
        {
          case p1 ⇒
            scalaxb.error.types.BranchType(p1.toSeq,
              scala.collection.immutable.ListMap(List(
                (node \ "@Type").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.BranchTypeEnumType](x, scalaxb.ElemName(node) :: stack)) } map { "@Type" -> _ },
                (node \ "@Name").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@Name" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.BranchType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@Type", _) ⇒ attr = scala.xml.Attribute(null, "Type", __obj.Type.toString, attr)
        case ("@Name", _) ⇒ attr = scala.xml.Attribute(null, "Name", __obj.Name.toString, attr)
        case (key, x)     ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.BranchType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.branchtypeoption flatMap { x ⇒ scalaxb.toXML[scalaxb.DataRecord[scalaxb.error.types.BranchTypeOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultTypesRelationshipFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Relationship] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/prod/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Relationship] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "FullProductName")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.Relationship(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.FullProductName](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@ProductReference").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@ProductReference" -> _ },
                (node \ "@RelationType").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.RelationTypeEnumType](x, scalaxb.ElemName(node) :: stack)) } map { "@RelationType" -> _ },
                (node \ "@RelatesToProductReference").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@RelatesToProductReference" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.Relationship, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@ProductReference", _)          ⇒ attr = scala.xml.Attribute(null, "ProductReference", __obj.ProductReference.toString, attr)
        case ("@RelationType", _)              ⇒ attr = scala.xml.Attribute(null, "RelationType", __obj.RelationType.toString, attr)
        case ("@RelatesToProductReference", _) ⇒ attr = scala.xml.Attribute(null, "RelatesToProductReference", __obj.RelatesToProductReference.toString, attr)
        case (key, x)                          ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Relationship, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.FullProductName flatMap { scalaxb.toXML[scalaxb.error.types.FullProductName](_, Some("http://www.icasi.org/CVRF/schema/prod/1.1"), Some("FullProductName"), __scope, false) })

  }

  trait DefaultTypesDescription4Format extends scalaxb.XMLFormat[scalaxb.error.types.Description4] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Description4] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/prod/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Description4] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Description4(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Description4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Description4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesGroupFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Group] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/prod/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Group] =
      phrase(opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "Description")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "ProductID")) ^^
        {
          case p1 ~ p2 ⇒
            scalaxb.error.types.Group(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.Description4](_, scalaxb.ElemName(node) :: stack) },
              p2.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@GroupID").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@GroupID" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.Group, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@GroupID", _) ⇒ attr = scala.xml.Attribute(null, "GroupID", __obj.GroupID.toString, attr)
        case (key, x)        ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Group, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.Description map { scalaxb.toXML[scalaxb.error.types.Description4](_, Some("http://www.icasi.org/CVRF/schema/prod/1.1"), Some("Description"), __scope, false) } getOrElse { Nil },
        __obj.ProductID flatMap { scalaxb.toXML[String](_, Some("http://www.icasi.org/CVRF/schema/prod/1.1"), Some("ProductID"), __scope, false) })

  }

  trait DefaultTypesProductGroupsFormat extends scalaxb.ElemNameParser[scalaxb.error.types.ProductGroups] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/prod/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.ProductGroups] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "Group")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.ProductGroups(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Group](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.ProductGroups, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Group flatMap { scalaxb.toXML[scalaxb.error.types.Group](_, Some("http://www.icasi.org/CVRF/schema/prod/1.1"), Some("Group"), __scope, false) })

  }

  trait DefaultTypesProductTreeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.ProductTree] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/prod/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.ProductTree] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "Branch")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "FullProductName")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "Relationship")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/prod/1.1"), "ProductGroups")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ⇒
            scalaxb.error.types.ProductTree(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.BranchType](_, scalaxb.ElemName(node) :: stack) },
              p2.toSeq map { scalaxb.fromXML[scalaxb.error.types.FullProductName](_, scalaxb.ElemName(node) :: stack) },
              p3.toSeq map { scalaxb.fromXML[scalaxb.error.types.Relationship](_, scalaxb.ElemName(node) :: stack) },
              p4.headOption map { scalaxb.fromXML[scalaxb.error.types.ProductGroups](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.ProductTree, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.Branch flatMap { scalaxb.toXML[scalaxb.error.types.BranchType](_, Some("http://www.icasi.org/CVRF/schema/prod/1.1"), Some("Branch"), __scope, false) },
        __obj.FullProductName flatMap { scalaxb.toXML[scalaxb.error.types.FullProductName](_, Some("http://www.icasi.org/CVRF/schema/prod/1.1"), Some("FullProductName"), __scope, false) },
        __obj.Relationship flatMap { scalaxb.toXML[scalaxb.error.types.Relationship](_, Some("http://www.icasi.org/CVRF/schema/prod/1.1"), Some("Relationship"), __scope, false) },
        __obj.ProductGroups map { scalaxb.toXML[scalaxb.error.types.ProductGroups](_, Some("http://www.icasi.org/CVRF/schema/prod/1.1"), Some("ProductGroups"), __scope, false) } getOrElse { Nil })

  }

  trait DefaultTypesFullProductNameFormat extends scalaxb.XMLFormat[scalaxb.error.types.FullProductName] with scalaxb.CanWriteChildNodes[scalaxb.error.types.FullProductName] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/prod/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.FullProductName] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.FullProductName(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@ProductID").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@ProductID" -> _ },
          (node \ "@CPE").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@CPE" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.FullProductName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@ProductID", _) ⇒ attr = scala.xml.Attribute(null, "ProductID", __obj.ProductID.toString, attr)
        case ("@CPE", _)       ⇒ __obj.CPE foreach { x ⇒ attr = scala.xml.Attribute(null, "CPE", x.toString, attr) }
        case (key, x)          ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.FullProductName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesCheckReferenceTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.CheckReferenceType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.CheckReferenceType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/scap-core/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CheckReferenceType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.CheckReferenceType(scala.collection.immutable.ListMap(List(
        (node \ "@system").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@system" -> _ },
        (node \ "@name").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@href").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@href" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.CheckReferenceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@system", _) ⇒ attr = scala.xml.Attribute(null, "system", __obj.system.toString, attr)
        case ("@name", _)   ⇒ __obj.name foreach { x ⇒ attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@href", _)   ⇒ attr = scala.xml.Attribute(null, "href", __obj.href.toString, attr)
        case (key, x)       ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.CheckReferenceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultTypesCheckSearchTypableFormat extends scalaxb.XMLFormat[scalaxb.error.types.CheckSearchTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CheckSearchTypable] = seq match {
      case node: scala.xml.Node ⇒
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://scap.nist.gov/schema/scap-core/1.0"), Some("checkReferenceType")) ⇒ Right(scalaxb.fromXML[scalaxb.error.types.CheckReferenceType](node, stack))
          case _ ⇒ Right(scalaxb.fromXML[scalaxb.error.types.CheckSearchType](node, stack))
        }
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def writes(__obj: scalaxb.error.types.CheckSearchTypable, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: scalaxb.error.types.CheckReferenceType ⇒ scalaxb.toXML[scalaxb.error.types.CheckReferenceType](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.CheckSearchType    ⇒ scalaxb.toXML[scalaxb.error.types.CheckSearchType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultTypesCheckSearchTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.CheckSearchType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.CheckSearchType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/scap-core/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CheckSearchType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.CheckSearchType(scala.collection.immutable.ListMap(List(
        (node \ "@system").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@system" -> _ },
        (node \ "@name").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.CheckSearchType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@system", _) ⇒ attr = scala.xml.Attribute(null, "system", __obj.system.toString, attr)
        case ("@name", _)   ⇒ __obj.name foreach { x ⇒ attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case (key, x)       ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.CheckSearchType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultTypesSearchableCpeReferencesTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.SearchableCpeReferencesType] with TypesCpeReferenceGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/scap-core/1.0")

    override def typeName: Option[String] = Some("searchableCpeReferencesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.SearchableCpeReferencesType] =
      phrase(safeRep(parseCpeReferenceGroupGroup(node, scalaxb.ElemName(node) :: stack)) ^^
        {
          case p1 ⇒
            scalaxb.error.types.SearchableCpeReferencesType(p1.toSeq: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.SearchableCpeReferencesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.cpeReferenceGroupOption1 flatMap { x ⇒ scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultTypesControlMappingsTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.ControlMappingsType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/scap-core/1.0")

    override def typeName: Option[String] = Some("controlMappingsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.ControlMappingsType] =
      phrase(safeRep(scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "control-mapping")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.ControlMappingsType(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.ControlMappingType](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.ControlMappingsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.controlu45mapping flatMap { scalaxb.toXML[scalaxb.error.types.ControlMappingType](_, Some("http://scap.nist.gov/schema/scap-core/1.0"), Some("control-mapping"), __scope, false) })

  }

  trait DefaultTypesControlMappingTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.ControlMappingType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/scap-core/1.0")

    override def typeName: Option[String] = Some("controlMappingType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.ControlMappingType] =
      phrase(safeRep(scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "mapping")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.ControlMappingType(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.MappingInstanceType](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@system-id").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@system-id" -> _ },
                (node \ "@source").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@source" -> _ },
                (node \ "@last-modified").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](x, scalaxb.ElemName(node) :: stack)) } map { "@last-modified" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.ControlMappingType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@system-id", _)     ⇒ attr = scala.xml.Attribute(null, "system-id", __obj.systemu45id.toString, attr)
        case ("@source", _)        ⇒ attr = scala.xml.Attribute(null, "source", __obj.source.toString, attr)
        case ("@last-modified", _) ⇒ attr = scala.xml.Attribute(null, "last-modified", __obj.lastu45modified.toString, attr)
        case (key, x)              ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.ControlMappingType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.mapping flatMap { scalaxb.toXML[scalaxb.error.types.MappingInstanceType](_, Some("http://scap.nist.gov/schema/scap-core/1.0"), Some("mapping"), __scope, false) })

  }

  trait DefaultTypesMappingInstanceTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.MappingInstanceType] with scalaxb.CanWriteChildNodes[scalaxb.error.types.MappingInstanceType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/scap-core/1.0")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.MappingInstanceType] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.MappingInstanceType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@published").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](x, scalaxb.ElemName(node) :: stack)) } map { "@published" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.MappingInstanceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@published", _) ⇒ attr = scala.xml.Attribute(null, "published", __obj.published.toString, attr)
        case (key, x)          ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.MappingInstanceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesAssessmentMethodTypableFormat extends scalaxb.XMLFormat[scalaxb.error.types.AssessmentMethodTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.AssessmentMethodTypable] = seq match {
      case node: scala.xml.Node ⇒
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://scap.nist.gov/schema/scap-core/1.0"), Some("identifyableAssessmentMethodType")) ⇒ Right(scalaxb.fromXML[scalaxb.error.types.IdentifyableAssessmentMethodType](node, stack))
          case _ ⇒ Right(scalaxb.fromXML[scalaxb.error.types.AssessmentMethodType](node, stack))
        }
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def writes(__obj: scalaxb.error.types.AssessmentMethodTypable, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: scalaxb.error.types.IdentifyableAssessmentMethodType ⇒ scalaxb.toXML[scalaxb.error.types.IdentifyableAssessmentMethodType](x, __namespace, __elementLabel, __scope, true)
      case x: scalaxb.error.types.AssessmentMethodType             ⇒ scalaxb.toXML[scalaxb.error.types.AssessmentMethodType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultTypesAssessmentMethodTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.AssessmentMethodType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/scap-core/1.0")

    override def typeName: Option[String] = Some("assessmentMethodType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.AssessmentMethodType] =
      phrase((scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "assessment-check")) ~
        safeRep(scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "assessment-engine")) ^^
        {
          case p1 ~ p2 ⇒
            scalaxb.error.types.AssessmentMethodType(scalaxb.fromXML[scalaxb.error.types.CheckReferenceType](p1, scalaxb.ElemName(node) :: stack),
              p2.toSeq map { scalaxb.fromXML[java.net.URI](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.AssessmentMethodType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[scalaxb.error.types.CheckReferenceType](__obj.assessmentu45check, Some("http://scap.nist.gov/schema/scap-core/1.0"), Some("assessment-check"), __scope, false),
        __obj.assessmentu45engine flatMap { scalaxb.toXML[java.net.URI](_, Some("http://scap.nist.gov/schema/scap-core/1.0"), Some("assessment-engine"), __scope, false) })

  }

  trait DefaultTypesIdentifyableAssessmentMethodTypeFormat extends scalaxb.ElemNameParser[scalaxb.error.types.IdentifyableAssessmentMethodType] {
    val targetNamespace: Option[String] = Some("http://scap.nist.gov/schema/scap-core/1.0")

    override def typeName: Option[String] = Some("identifyableAssessmentMethodType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.IdentifyableAssessmentMethodType] =
      phrase((scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "assessment-check")) ~
        safeRep(scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "assessment-engine")) ^^
        {
          case p1 ~ p2 ⇒
            scalaxb.error.types.IdentifyableAssessmentMethodType(scalaxb.fromXML[scalaxb.error.types.CheckReferenceType](p1, scalaxb.ElemName(node) :: stack),
              p2.toSeq map { scalaxb.fromXML[java.net.URI](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@id").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.IdentifyableAssessmentMethodType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) ⇒ __obj.id foreach { x ⇒ attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x)   ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.IdentifyableAssessmentMethodType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[scalaxb.error.types.CheckReferenceType](__obj.assessmentu45check, Some("http://scap.nist.gov/schema/scap-core/1.0"), Some("assessment-check"), __scope, false),
        __obj.assessmentu45engine flatMap { scalaxb.toXML[java.net.URI](_, Some("http://scap.nist.gov/schema/scap-core/1.0"), Some("assessment-engine"), __scope, false) })

  }

  trait TypesCpeReferenceGroupGroupFormat extends scalaxb.AnyElemNameParser {
    def parseCpeReferenceGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "cpe-name")) ^^
        (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)))) |
        ((scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "cpe-searchable-name")) ^^
          (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)))))

    def parseCpeReferenceGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "cpe-name")) ^^
        (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)))) |
        ((scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "cpe-searchable-name")) ^^
          (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)))))

    def parsemixedCpeReferenceGroupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "cpe-name")) ^^
        (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)))) ~
        optTextRecord) ^^
        {
          case p1 ~ p2 ⇒ Seq.concat(Seq(p1),
            p2.toList)
        }) |||
        ((((scalaxb.ElemName(Some("http://scap.nist.gov/schema/scap-core/1.0"), "cpe-searchable-name")) ^^
          (x ⇒ scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)))) ~
          optTextRecord) ^^
          {
            case p1 ~ p2 ⇒ Seq.concat(Seq(p1),
              p2.toList)
          }))
  }

  def buildTypesInvolvementStatusEnumTypeFormat = new DefaultTypesInvolvementStatusEnumTypeFormat {}
  trait DefaultTypesInvolvementStatusEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.InvolvementStatusEnumType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.InvolvementStatusEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.InvolvementStatusEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.InvolvementStatusEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.InvolvementStatusEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesAffectedStatusEnumTypeFormat = new DefaultTypesAffectedStatusEnumTypeFormat {}
  trait DefaultTypesAffectedStatusEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.AffectedStatusEnumType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.AffectedStatusEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.AffectedStatusEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.AffectedStatusEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.AffectedStatusEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesThreatTypeEnumTypeFormat = new DefaultTypesThreatTypeEnumTypeFormat {}
  trait DefaultTypesThreatTypeEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.ThreatTypeEnumType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.ThreatTypeEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.ThreatTypeEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.ThreatTypeEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.ThreatTypeEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildTypesRemedyTypeEnumTypeFormat = new DefaultTypesRemedyTypeEnumTypeFormat {}
  trait DefaultTypesRemedyTypeEnumTypeFormat extends scalaxb.XMLFormat[scalaxb.error.types.RemedyTypeEnumType] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.RemedyTypeEnumType] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.RemedyTypeEnumType.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.RemedyTypeEnumType.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.RemedyTypeEnumType, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultTypesTitleFormat extends scalaxb.XMLFormat[scalaxb.error.types.Title] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Title] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Title] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Title(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Title, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Title, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesID2Format extends scalaxb.XMLFormat[scalaxb.error.types.ID2] with scalaxb.CanWriteChildNodes[scalaxb.error.types.ID2] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.ID2] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.ID2(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@SystemName").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@SystemName" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.ID2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@SystemName", _) ⇒ attr = scala.xml.Attribute(null, "SystemName", __obj.SystemName.toString, attr)
        case (key, x)           ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.ID2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesNote2Format extends scalaxb.XMLFormat[scalaxb.error.types.Note2] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Note2] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Note2] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Note2(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
          (node \ "@Title").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@Title" -> _ },
          (node \ "@Audience").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@Audience" -> _ },
          (node \ "@Type").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.NoteTypeEnumType](x, scalaxb.ElemName(node) :: stack)) } map { "@Type" -> _ },
          (node \ "@Ordinal").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@Ordinal" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Note2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case ("@Title", _) ⇒ __obj.Title foreach { x ⇒ attr = scala.xml.Attribute(null, "Title", x.toString, attr) }
        case ("@Audience", _) ⇒ __obj.Audience foreach { x ⇒ attr = scala.xml.Attribute(null, "Audience", x.toString, attr) }
        case ("@Type", _) ⇒ attr = scala.xml.Attribute(null, "Type", __obj.Type.toString, attr)
        case ("@Ordinal", _) ⇒ attr = scala.xml.Attribute(null, "Ordinal", __obj.Ordinal.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Note2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesNotesFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Notes] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Notes] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Note")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.Notes(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Note2](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.Notes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Note flatMap { scalaxb.toXML[scalaxb.error.types.Note2](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Note"), __scope, false) })

  }

  trait DefaultTypesDescription5Format extends scalaxb.XMLFormat[scalaxb.error.types.Description5] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Description5] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Description5] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Description5(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Description5, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Description5, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesInvolvementFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Involvement] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Involvement] =
      phrase(opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Description")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.Involvement(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.Description5](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@Party").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.PublisherEnumType](x, scalaxb.ElemName(node) :: stack)) } map { "@Party" -> _ },
                (node \ "@Status").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.InvolvementStatusEnumType](x, scalaxb.ElemName(node) :: stack)) } map { "@Status" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.Involvement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@Party", _)  ⇒ attr = scala.xml.Attribute(null, "Party", __obj.Party.toString, attr)
        case ("@Status", _) ⇒ attr = scala.xml.Attribute(null, "Status", __obj.Status.toString, attr)
        case (key, x)       ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Involvement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Description map { scalaxb.toXML[scalaxb.error.types.Description5](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Description"), __scope, false) } getOrElse { Nil })

  }

  trait DefaultTypesInvolvementsFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Involvements] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Involvements] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Involvement")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.Involvements(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Involvement](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.Involvements, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Involvement flatMap { scalaxb.toXML[scalaxb.error.types.Involvement](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Involvement"), __scope, false) })

  }

  trait DefaultTypesCWEFormat extends scalaxb.XMLFormat[scalaxb.error.types.CWE] with scalaxb.CanWriteChildNodes[scalaxb.error.types.CWE] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.CWE] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.CWE(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
          (node \ "@ID").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@ID" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.CWE, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case ("@ID", _) ⇒ attr = scala.xml.Attribute(null, "ID", __obj.ID.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.CWE, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesStatusFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Status] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Status] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "ProductID")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.Status(p1.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@Type").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.AffectedStatusEnumType](x, scalaxb.ElemName(node) :: stack)) } map { "@Type" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.Status, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@Type", _) ⇒ attr = scala.xml.Attribute(null, "Type", __obj.Type.toString, attr)
        case (key, x)     ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Status, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.ProductID flatMap { scalaxb.toXML[String](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("ProductID"), __scope, false) })

  }

  trait DefaultTypesProductStatusesFormat extends scalaxb.ElemNameParser[scalaxb.error.types.ProductStatuses] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.ProductStatuses] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Status")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.ProductStatuses(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Status](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.ProductStatuses, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Status flatMap { scalaxb.toXML[scalaxb.error.types.Status](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Status"), __scope, false) })

  }

  trait DefaultTypesDescription6Format extends scalaxb.XMLFormat[scalaxb.error.types.Description6] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Description6] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Description6] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Description6(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Description6, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Description6, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesThreatFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Threat] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Threat] =
      phrase((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Description")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "ProductID")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "GroupID")) ^^
        {
          case p1 ~ p2 ~ p3 ⇒
            scalaxb.error.types.Threat(scalaxb.fromXML[scalaxb.error.types.Description6](p1, scalaxb.ElemName(node) :: stack),
              p2.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
              p3.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@Type").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.ThreatTypeEnumType](x, scalaxb.ElemName(node) :: stack)) } map { "@Type" -> _ },
                (node \ "@Date").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](x, scalaxb.ElemName(node) :: stack)) } map { "@Date" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.Threat, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@Type", _) ⇒ attr = scala.xml.Attribute(null, "Type", __obj.Type.toString, attr)
        case ("@Date", _) ⇒ __obj.Date foreach { x ⇒ attr = scala.xml.Attribute(null, "Date", x.toString, attr) }
        case (key, x)     ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Threat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[scalaxb.error.types.Description6](__obj.Description, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Description"), __scope, false),
        __obj.ProductID flatMap { scalaxb.toXML[String](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("ProductID"), __scope, false) },
        __obj.GroupID flatMap { scalaxb.toXML[String](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("GroupID"), __scope, false) })

  }

  trait DefaultTypesThreatsFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Threats] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Threats] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Threat")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.Threats(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Threat](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.Threats, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Threat flatMap { scalaxb.toXML[scalaxb.error.types.Threat](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Threat"), __scope, false) })

  }

  trait DefaultTypesScoreSetFormat extends scalaxb.ElemNameParser[scalaxb.error.types.ScoreSet] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.ScoreSet] =
      phrase((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "BaseScore")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "TemporalScore")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "EnvironmentalScore")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Vector")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "ProductID")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ⇒
            scalaxb.error.types.ScoreSet(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
              p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
              p3.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
              p4.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
              p5.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.ScoreSet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigDecimal](__obj.BaseScore, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("BaseScore"), __scope, false),
        __obj.TemporalScore map { scalaxb.toXML[BigDecimal](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("TemporalScore"), __scope, false) } getOrElse { Nil },
        __obj.EnvironmentalScore map { scalaxb.toXML[BigDecimal](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("EnvironmentalScore"), __scope, false) } getOrElse { Nil },
        __obj.Vector map { scalaxb.toXML[String](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Vector"), __scope, false) } getOrElse { Nil },
        __obj.ProductID flatMap { scalaxb.toXML[String](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("ProductID"), __scope, false) })

  }

  trait DefaultTypesCVSSScoreSetsFormat extends scalaxb.ElemNameParser[scalaxb.error.types.CVSSScoreSets] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.CVSSScoreSets] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "ScoreSet")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.CVSSScoreSets(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.ScoreSet](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.CVSSScoreSets, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.ScoreSet flatMap { scalaxb.toXML[scalaxb.error.types.ScoreSet](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("ScoreSet"), __scope, false) })

  }

  trait DefaultTypesDescription7Format extends scalaxb.XMLFormat[scalaxb.error.types.Description7] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Description7] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Description7] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Description7(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Description7, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Description7, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesEntitlementFormat extends scalaxb.XMLFormat[scalaxb.error.types.Entitlement] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Entitlement] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Entitlement] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Entitlement(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Entitlement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Entitlement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesRemediationFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Remediation] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Remediation] =
      phrase((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Description")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Entitlement")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "URL")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "ProductID")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "GroupID")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ⇒
            scalaxb.error.types.Remediation(scalaxb.fromXML[scalaxb.error.types.Description7](p1, scalaxb.ElemName(node) :: stack),
              p2.toSeq map { scalaxb.fromXML[scalaxb.error.types.Entitlement](_, scalaxb.ElemName(node) :: stack) },
              p3.headOption map { scalaxb.fromXML[java.net.URI](_, scalaxb.ElemName(node) :: stack) },
              p4.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
              p5.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@Type").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.RemedyTypeEnumType](x, scalaxb.ElemName(node) :: stack)) } map { "@Type" -> _ },
                (node \ "@Date").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](x, scalaxb.ElemName(node) :: stack)) } map { "@Date" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.Remediation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@Type", _) ⇒ attr = scala.xml.Attribute(null, "Type", __obj.Type.toString, attr)
        case ("@Date", _) ⇒ __obj.Date foreach { x ⇒ attr = scala.xml.Attribute(null, "Date", x.toString, attr) }
        case (key, x)     ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Remediation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[scalaxb.error.types.Description7](__obj.Description, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Description"), __scope, false),
        __obj.Entitlement flatMap { scalaxb.toXML[scalaxb.error.types.Entitlement](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Entitlement"), __scope, false) },
        __obj.URL map { scalaxb.toXML[java.net.URI](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("URL"), __scope, false) } getOrElse { Nil },
        __obj.ProductID flatMap { scalaxb.toXML[String](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("ProductID"), __scope, false) },
        __obj.GroupID flatMap { scalaxb.toXML[String](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("GroupID"), __scope, false) })

  }

  trait DefaultTypesRemediationsFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Remediations] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Remediations] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Remediation")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.Remediations(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Remediation](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.Remediations, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Remediation flatMap { scalaxb.toXML[scalaxb.error.types.Remediation](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Remediation"), __scope, false) })

  }

  trait DefaultTypesDescription8Format extends scalaxb.XMLFormat[scalaxb.error.types.Description8] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Description8] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Description8] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Description8(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Description8, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Description8, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesReference2Format extends scalaxb.ElemNameParser[scalaxb.error.types.Reference2] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Reference2] =
      phrase((scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "URL")) ~
        (scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Description")) ^^
        {
          case p1 ~ p2 ⇒
            scalaxb.error.types.Reference2(scalaxb.fromXML[java.net.URI](p1, scalaxb.ElemName(node) :: stack),
              scalaxb.fromXML[scalaxb.error.types.Description8](p2, scalaxb.ElemName(node) :: stack),
              scala.collection.immutable.ListMap(List(
                (node \ "@Type").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.error.types.ReferenceTypeEnum](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[scalaxb.error.types.ReferenceTypeEnum](scala.xml.Text("External"), scalaxb.ElemName(node) :: stack))) map { "@Type" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.Reference2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@Type", _) ⇒ if (__obj.Type.toString != "External") attr = scala.xml.Attribute(null, "Type", __obj.Type.toString, attr)
        case (key, x)     ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Reference2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[java.net.URI](__obj.URL, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("URL"), __scope, false),
        scalaxb.toXML[scalaxb.error.types.Description8](__obj.Description, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Description"), __scope, false))

  }

  trait DefaultTypesReferencesFormat extends scalaxb.ElemNameParser[scalaxb.error.types.References] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.References] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Reference")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.References(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Reference2](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.References, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Reference flatMap { scalaxb.toXML[scalaxb.error.types.Reference2](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Reference"), __scope, false) })

  }

  trait DefaultTypesName2Format extends scalaxb.XMLFormat[scalaxb.error.types.Name2] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Name2] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Name2] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Name2(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Name2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Name2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesOrganization2Format extends scalaxb.XMLFormat[scalaxb.error.types.Organization2] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Organization2] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Organization2] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Organization2(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Organization2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Organization2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesDescription9Format extends scalaxb.XMLFormat[scalaxb.error.types.Description9] with scalaxb.CanWriteChildNodes[scalaxb.error.types.Description9] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")
    import scalaxb.ElemName._

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Description9] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.Description9(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("en"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: scalaxb.error.types.Description9, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) ⇒ if (__obj.xmllang.toString != "en") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Description9, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultTypesAcknowledgment2Format extends scalaxb.ElemNameParser[scalaxb.error.types.Acknowledgment2] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Acknowledgment2] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Name")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Organization")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Description")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "URL")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ⇒
            scalaxb.error.types.Acknowledgment2(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Name2](_, scalaxb.ElemName(node) :: stack) },
              p2.toSeq map { scalaxb.fromXML[scalaxb.error.types.Organization2](_, scalaxb.ElemName(node) :: stack) },
              p3.headOption map { scalaxb.fromXML[scalaxb.error.types.Description9](_, scalaxb.ElemName(node) :: stack) },
              p4.toSeq map { scalaxb.fromXML[java.net.URI](_, scalaxb.ElemName(node) :: stack) })
        })

    def writesChildNodes(__obj: scalaxb.error.types.Acknowledgment2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.Name flatMap { scalaxb.toXML[scalaxb.error.types.Name2](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Name"), __scope, false) },
        __obj.Organization flatMap { scalaxb.toXML[scalaxb.error.types.Organization2](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Organization"), __scope, false) },
        __obj.Description map { scalaxb.toXML[scalaxb.error.types.Description9](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Description"), __scope, false) } getOrElse { Nil },
        __obj.URL flatMap { scalaxb.toXML[java.net.URI](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("URL"), __scope, false) })

  }

  trait DefaultTypesAcknowledgments2Format extends scalaxb.ElemNameParser[scalaxb.error.types.Acknowledgments2] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Acknowledgments2] =
      phrase(safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Acknowledgment")) ^^
        {
          case p1 ⇒
            scalaxb.error.types.Acknowledgments2(p1.toSeq map { scalaxb.fromXML[scalaxb.error.types.Acknowledgment2](_, scalaxb.ElemName(node) :: stack) }: _*)
        })

    def writesChildNodes(__obj: scalaxb.error.types.Acknowledgments2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Acknowledgment flatMap { scalaxb.toXML[scalaxb.error.types.Acknowledgment2](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Acknowledgment"), __scope, false) })

  }

  trait DefaultTypesVulnerabilityFormat extends scalaxb.ElemNameParser[scalaxb.error.types.Vulnerability] {
    val targetNamespace: Option[String] = Some("http://www.icasi.org/CVRF/schema/vuln/1.1")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.error.types.Vulnerability] =
      phrase(opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Title")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "ID")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Notes")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "DiscoveryDate")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "ReleaseDate")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Involvements")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "CVE")) ~
        safeRep(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "CWE")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "ProductStatuses")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Threats")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "CVSSScoreSets")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Remediations")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "References")) ~
        opt(scalaxb.ElemName(Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), "Acknowledgments")) ^^
        {
          case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ⇒
            scalaxb.error.types.Vulnerability(p1.headOption map { scalaxb.fromXML[scalaxb.error.types.Title](_, scalaxb.ElemName(node) :: stack) },
              p2.headOption map { scalaxb.fromXML[scalaxb.error.types.ID2](_, scalaxb.ElemName(node) :: stack) },
              p3.headOption map { scalaxb.fromXML[scalaxb.error.types.Notes](_, scalaxb.ElemName(node) :: stack) },
              p4.headOption map { scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](_, scalaxb.ElemName(node) :: stack) },
              p5.headOption map { scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](_, scalaxb.ElemName(node) :: stack) },
              p6.headOption map { scalaxb.fromXML[scalaxb.error.types.Involvements](_, scalaxb.ElemName(node) :: stack) },
              p7.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
              p8.toSeq map { scalaxb.fromXML[scalaxb.error.types.CWE](_, scalaxb.ElemName(node) :: stack) },
              p9.headOption map { scalaxb.fromXML[scalaxb.error.types.ProductStatuses](_, scalaxb.ElemName(node) :: stack) },
              p10.headOption map { scalaxb.fromXML[scalaxb.error.types.Threats](_, scalaxb.ElemName(node) :: stack) },
              p11.headOption map { scalaxb.fromXML[scalaxb.error.types.CVSSScoreSets](_, scalaxb.ElemName(node) :: stack) },
              p12.headOption map { scalaxb.fromXML[scalaxb.error.types.Remediations](_, scalaxb.ElemName(node) :: stack) },
              p13.headOption map { scalaxb.fromXML[scalaxb.error.types.References](_, scalaxb.ElemName(node) :: stack) },
              p14.headOption map { scalaxb.fromXML[scalaxb.error.types.Acknowledgments2](_, scalaxb.ElemName(node) :: stack) },
              scala.collection.immutable.ListMap(List(
                (node \ "@Ordinal").headOption map { x ⇒ scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@Ordinal" -> _ }).flatten[(String, scalaxb.DataRecord[Any])]: _*))
        })

    override def writesAttribute(__obj: scalaxb.error.types.Vulnerability, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@Ordinal", _) ⇒ attr = scala.xml.Attribute(null, "Ordinal", __obj.Ordinal.toString, attr)
        case (key, x)        ⇒ attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: scalaxb.error.types.Vulnerability, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.Title map { scalaxb.toXML[scalaxb.error.types.Title](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Title"), __scope, false) } getOrElse { Nil },
        __obj.ID map { scalaxb.toXML[scalaxb.error.types.ID2](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("ID"), __scope, false) } getOrElse { Nil },
        __obj.Notes map { scalaxb.toXML[scalaxb.error.types.Notes](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Notes"), __scope, false) } getOrElse { Nil },
        __obj.DiscoveryDate map { scalaxb.toXML[javax.xml.datatype.XMLGregorianCalendar](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("DiscoveryDate"), __scope, false) } getOrElse { Nil },
        __obj.ReleaseDate map { scalaxb.toXML[javax.xml.datatype.XMLGregorianCalendar](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("ReleaseDate"), __scope, false) } getOrElse { Nil },
        __obj.Involvements map { scalaxb.toXML[scalaxb.error.types.Involvements](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Involvements"), __scope, false) } getOrElse { Nil },
        __obj.CVE map { scalaxb.toXML[String](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("CVE"), __scope, false) } getOrElse { Nil },
        __obj.CWE flatMap { scalaxb.toXML[scalaxb.error.types.CWE](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("CWE"), __scope, false) },
        __obj.ProductStatuses map { scalaxb.toXML[scalaxb.error.types.ProductStatuses](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("ProductStatuses"), __scope, false) } getOrElse { Nil },
        __obj.Threats map { scalaxb.toXML[scalaxb.error.types.Threats](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Threats"), __scope, false) } getOrElse { Nil },
        __obj.CVSSScoreSets map { scalaxb.toXML[scalaxb.error.types.CVSSScoreSets](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("CVSSScoreSets"), __scope, false) } getOrElse { Nil },
        __obj.Remediations map { scalaxb.toXML[scalaxb.error.types.Remediations](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Remediations"), __scope, false) } getOrElse { Nil },
        __obj.References map { scalaxb.toXML[scalaxb.error.types.References](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("References"), __scope, false) } getOrElse { Nil },
        __obj.Acknowledgments map { scalaxb.toXML[scalaxb.error.types.Acknowledgments2](_, Some("http://www.icasi.org/CVRF/schema/vuln/1.1"), Some("Acknowledgments"), __scope, false) } getOrElse { Nil })

  }

  def buildTypesSpaceFormat = new DefaultTypesSpaceFormat {}
  trait DefaultTypesSpaceFormat extends scalaxb.XMLFormat[scalaxb.error.types.Space] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/XML/1998/namespace")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.Space] = seq match {
      case elem: scala.xml.Elem ⇒ Right(scalaxb.error.types.Space.fromString(elem.text, elem.scope))
      case _                    ⇒ Right(scalaxb.error.types.Space.fromString(seq.text, scala.xml.TopScope))
    }

    def writes(__obj: scalaxb.error.types.Space, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultTypesSpecialAttrsFormat extends scalaxb.AttributeGroupFormat[scalaxb.error.types.SpecialAttrs] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/XML/1998/namespace")

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, scalaxb.error.types.SpecialAttrs] = seq match {
      case node: scala.xml.Node ⇒ Right(scalaxb.error.types.SpecialAttrs((node \ "@{http://www.w3.org/XML/1998/namespace}base").headOption map { scalaxb.fromXML[java.net.URI](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@{http://www.w3.org/XML/1998/namespace}space").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ ⇒ Left("reads failed: seq must be scala.xml.Node")
    }

    def toAttribute(__obj: scalaxb.error.types.SpecialAttrs, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = __attr
      __obj.xmlbase foreach { x ⇒ attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "base", x.toString, attr) }
      __obj.xmllang foreach { x ⇒ attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
      __obj.xmlspace foreach { x ⇒ attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "space", x.toString, attr) }
      attr
    }
  }

}

